.. ****************************************************************************
.. CUI
..
.. The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
..
.. The use, dissemination or disclosure of data in this file is subject to
.. limitation or restriction. See accompanying README and LICENSE for details.
.. ****************************************************************************

osm_traffic
-----------

.. command:: osm_traffic ... end_osm_traffic
   :block:

Script Class: :class:`WsfOSM_Traffic`

.. parsed-literal::

  osm_traffic_
    debug_ <boolean-value>
    network_ <route-network-name>
      vehicle_count_ <positive-integer>
      maximum_speed_ <speed-value>

      vehicle_ <platform-type>
        fraction_ <real-value>
        mean_speed_ <speed-value>
        sigma_speed_ <speed-value>
        ignore_speed_limits_
      end_vehicle

      route_aux_data_mapping_
        minimum_speed_ <string>
        maximum_speed_ <string>
        lanes_ <string>
        one_way_ <string>
        density_ <string>
        surface_ <string>
      end_route_aux_data_mapping

      waypoint_aux_data_mapping_
        stop_ <string>
        traffic_signals_ <string>
        highway_ <string>
      end_waypoint_aux_data_mapping
    end_network
  end_osm_traffic

Overview
========
The osm_traffic command generates background road traffic via ground moving platforms during the simulation on a predefined :command:`route_network`. This capability is similar to the :command:`road_traffic` command; the primary difference between the two is that osm_traffic_ is designed to be used with :command:`route_network`\ s generated by *Wizard's OSM Converter Tool*. This converter allows for additional :command:`route` commands to be utilized in the generation of the traffic via the :command:`route.aux_data` as further described below.

Operations
==========

Generated background traffic vehicles will adhere to the general rules of the road as specified in the :command:`route.aux_data`, and are responsible for the following behaviors.

* Stopping accordingly at traffic lights and stop signs
* Lining up at intersections when traffic becomes congested
* Observing minimum and maximum speed limits (minimum_speed_ and maximum_speed_)
* Attempting to avoid collisions by changing lanes and speeds as necessary

Road data such as speed limits and traffic lights should be added through the route and waypoint aux_data sections, then mapped to the osm_traffic command via the route_aux_data_mapping_ and waypoint_aux_data_mapping_ blocks.

.. note::
   osm_traffic_ modifies the routes and their associated names to provide a more realistic representation of the routes as roads. The rules, naming conventions and an example route name are provided below. The described suffixes are computer generated, and appear in the order they are listed. :class:`Script methods <WsfOSM_Traffic>` are available for routes to simplify access lookups.

   * Intersections are modeled visually as small blank spaces without any routes running through them. When a single route passes through multiple intersections, it is split into several parts, designated by double underscores followed by a numeric "segment" suffix. The segments are numbered in the order of traversal in the original route input.
   * Most roads are bidirectional, but only a single route input is provided. As a result, when necessary, osm_traffic_ internally creates new routes going in the opposite direction. These are designated by a double underscore followed by either a "normal" or "opposite" suffix, with "normal" referring to the input route's original direction.
   * Routes with X lanes are split into X different routes (up to ten lanes). Even when there is only one lane, every route name has a numeric suffix that designates which lane it represents.
   * Example: "Lackland_Road__1__normal2", which means Lackland_Road, segment 1, 2nd lane going in the normal direction.

osm_traffic_ is also compatible with scripted vehicles. For scripted vehicles, it is the user's decision to follow (or ignore) the rules of the road. However, as long as the associated commands are used, the background traffic will be aware of these added vehicles, and will attempt to avoid rear collisions with them when possible. More information regarding the osm_traffic_ script methods can be found at :class:`WsfOSM_Traffic`.

.. note::
   Currently route_networks will not be drawn on the map display. A simple example is provided below that demonstrates how to visualize the route network.

Commands
========

.. command:: debug <boolean-value>

   Enables or disables debugging output to command line (standard out). Provides more verbose information for debugging when true.

   **Default** false

.. command:: network <route-network-name> ... end_network
   :block:

   Defines the attributes and vehicles that are generated on the defined :command:`route_network` as specified by the <route-network-name>.

   .. command:: vehicle_count <positive-integer>

      Specifies the number of vehicles that will be generated on the route network.

   .. command:: maximum_speed  <speed-value>

      The maximum speed any vehicle on the network can travel even if a faster speed is specified in the vehicle block. Generally, it will be more effective to define speed limits for individual routes or to define a maximum speed on the ground mover itself.

   .. command:: vehicle <platform-type> end_vehicle
      :block:

      Defines the attributes of a specific vehicle type within the context of this network. To define multiple vehicle types, create multiple vehicle blocks. The <platform-type> must be a previously defined platform_type.

      .. command:: fraction <real-value>

         If multiple vehicle blocks are defined, the fraction is the percentage (as a decimal value) of this specific vehicle type that would populate the road network.   The sum of all the vehicle fractions must add up to 1.

      .. command:: mean_speed  <speed-value>

         The average speed of all the vehicles defined by this vehicle block. This value will only be used when no speed limits (maximum_speed_ or minimum_speed_) are defined on a particular route or if the ignore_speed_limits_ flag is set.

      .. command:: sigma_speed  <speed-value>

         The speed magnitude of one standard deviation. This command follows same conditions as mean_speed_.

      .. command:: ignore_speed_limits

         Indicates that vehicles of the specified type do not need to follow the speed limits defined by maximum_speed_ or minimum_speed_

   .. end::

   .. command:: route_aux_data_mapping ... end_route_aux_data_mapping
      :block:

      This block applies to all routes in the :command:`route_network`, and maps osm_traffic_ route aux_data variable names to the rules of the road. The parameter for each command is simply a string representation of the variables' name as defined in the route aux_data input blocks.

      .. note::
         Ensure that the naming conventions of desired features is consistent across all of the routes in the route_network (i.e. the aux_data variable name for maximum_speed_ should be the same across all routes).

      .. command:: minimum_speed <aux-data-variable-name>

         Maps an aux_data numeric variable to the route's minimum speed.

         .. note::
           If a minimum_speed_ string is not found on the route, then minimum speed will be half the maximum_speed_ if it is found instead.

         **Default** minspeed

      .. command:: maximum_speed <aux-data-variable-name>

         Maps an aux_data numeric variable to the route's maximum speed.

         .. note::
           If a maximum_speed_ string is not found on the route, then maximum speed will be double the minimum_speed_ if it is found instead.

         **Default** maxspeed

      .. command:: lanes <aux-data-variable-name>

         Maps an aux_data integer variable to the number of lanes in the route. This defines the number of lanes traveling in both directions, unless otherwise specified. By default, on a two-way road, there will be two lanes (one for each direction).

         **Default** lanes

      .. command:: one_way <aux-data-variable-name>

         Maps an aux_data boolean variable to whether a road is one way or not. This will also affect how lanes are interpreted.

         **Default** oneway

      .. command:: density <aux-data-variable-name>

         Maps an aux_data integer variable to a road's average vehicle density.

         .. note::
            This input will only apply to background vehicles; any additional scripted vehicles will not be considered when populating and traveling through roads.

         **Default** density

      .. command:: surface <aux-data-variable-name>

         Maps an aux_data string variable to a road's surface type.

         .. note::
            This aux_data field is currently not utilized by the osm_traffic_ generated traffic.

         **Default** surface

   .. end::

   .. command:: waypoint_aux_data_mapping ... end_waypoint_aux_data_mapping
      :block:

      This block applies to all waypoints in the :command:`route_network`, and maps the osm_traffic waypoint aux_data variables names to the rules of the road.

      .. note::
         The parameter usage and naming convention rules are the same as in the route_aux_data_mapping_ block.

      .. warning::
         The aux_data will be ignored unless the waypoint has a :command:`route.node_id`; stop signs and traffic lights are inconsequential when there are no connected roads.

      .. command:: stop <aux-data-variable-name>

         Maps an aux_data boolean variable to whether a waypoint is a stop sign.

         .. note::
            By default, the waypoint will not be treated as a stop sign.

         **Default** stop

      .. command:: traffic_signals <aux-data-variable-name>

         Maps an aux_data boolean variable to whether a waypoint has a traffic light.

         .. note::
            By default, there will be no traffic light.

         **Default** traffic_signals

      .. command:: highway <aux-data-variable-name>

         Maps an aux_data boolean variable to highway description / type.

         .. note::
            By default, there will be no highway.

         **Default** highway

   .. end::

Example
=======

.. parsed-literal::

   osm_traffic_
     network_ osm_netowrk
       vehicle_count_ 500
       maximum_speed_  75 mi/h
       vehicle_ Car
         fraction_      0.80
         mean_speed_   60 mi/h
         sigma_speed_   5 mi/h
       end_vehicle
       vehicle_ Pickup_Truck
         fraction_      0.15
         mean_speed_   60 mi/h
         sigma_speed_  10 mi/h
       end_vehicle
       vehicle_ School_Bus
         fraction_      0.05
         mean_speed_   50 mi/h
         sigma_speed_  10 mi/h
       end_vehicle
     end_network
   end_osm_traffic

WsfDraw Examples
================

.. parsed-literal::

    # Simple script to visualize the road network
    # the string literals may change based on what the aux_data variable and network names actually are
    script void DrawRoads()
       WsfDraw draw = WsfDraw();
       WsfRouteNetwork network = WsfRouteNetwork.FindRouteNetwork("network_name");
       WsfOSMTraffic traffic = WsfOSMTraffic.GetTraffic();
       Array<WsfRoute> trafficRoutes = traffic.GetTrafficRoutes("network_name");

       foreach (WsfRoute rte in trafficRoutes)
       {
          WsfRoute route = rte.Copy();
          route.SetAltitude(10);
          draw.SetColor(.93,.51,.93);
          draw.SetLayer(route.Name());
          draw.SetId(route.Name());
          draw.SetLineSize(2);
          draw.BeginPolyline();
          draw.VertexRoute(route);
          draw.End();
          draw.SetId(route.Name());
          draw.SetTextSize(6);
          draw.SetColor(0,0,0);
          # If aux_data should be listed on the map, uncomment and add to this section
          #    if (route.AuxDataExists("maxspeed") || route.AuxDataExists("name"))
          #    {
          #       string name = (string)route.AuxDataInt("name");
          #       string speedLimit = (string)route.AuxDataDouble("maxspeed") + " mph";
          #       draw.BeginText(name);
          #    }
          draw.BeginText(route.Name());
          WsfGeoPoint textPos = route.Waypoint(0).Location();
          textPos.SetAltitudeAGL(30);
          draw.Vertex(textPos);
          #draw.Vertex(route.Waypoint(0).Location());
          draw.End();
          draw.SetColor(0,0,0);
          draw.SetLineSize(1);
          draw.BeginLines();
          draw.Vertex(route.Waypoint(0).Location());
          draw.Vertex(textPos);
          draw.End();
       }
    end_script

    # Simple script to draw colored shapes where stop signs and traffic lights are located
    script void DrawStops()
       WsfDraw draw = WsfDraw();
       WsfRouteNetwork network = WsfRouteNetwork.FindRouteNetwork("network_name");
       foreach (WsfRoute rte in network.Routes()) {
          WsfRoute route = rte.Copy();
          foreach (WsfWaypoint node in route) {
             if (node.AuxDataExists("stop_sign") &&
                 node.AuxDataBool("stop_sign"))
             {
                draw.SetColor(1,0,0);
                draw.SetEllipseMode("fill");
                draw.BeginCircle(0, 100);
                draw.VertexLLA(node.Latitude(), node.Longitude(), 0);
                draw.End();
             }

             if (node.AuxDataExists("traffic_signals") &&
                 node.AuxDataBool("traffic_signals"))
             {
                draw.SetColor(1,1,0);
                draw.SetEllipseMode("fill");
                draw.BeginCircle(0, 100);
                draw.VertexLLA(node.Latitude(), node.Longitude(), 0);
                draw.End();
             }
          }
       }
    end_script
