// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************
// ****************************************************************************
// Updated by Infoscitex, a DCS Company.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See util_script/source/script_parser/AAA_README.TXT.

#include "UtScriptLanguageScanner.hpp"

#include "UtCast.hpp"

namespace UtScriptLanguage
{

// string handling, wide character

cocochar_t* coco_string_create(const cocochar_t* value)
{
   return coco_string_create(value, 0);
}

cocochar_t* coco_string_create(const cocochar_t* value, int startIndex)
{
   int len = 0;

   if (value)
   {
      int valueLen = COCO_Str::len(value);
      len          = valueLen - startIndex;
   }

   return coco_string_create(value, startIndex, len);
}

cocochar_t* coco_string_create(const cocochar_t* value, int startIndex, int length)
{
   int         len = 0;
   cocochar_t* data;

   if (value)
   {
      len = length;
   }
   data = new cocochar_t[len + 1];
   COCO_Str::ncpy(data, &(value[startIndex]), len);
   data[len] = 0;

   return data;
}

cocochar_t* coco_string_create_upper(const cocochar_t* data)
{
   if (!data)
   {
      return nullptr;
   }

   int dataLen = 0;
   if (data)
   {
      dataLen = COCO_Str::len(data);
   }

   cocochar_t* newData = new cocochar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++)
   {
      if (('a' <= data[i]) && (data[i] <= 'z'))
      {
         newData[i] = data[i] + ('A' - 'a');
      }
      else
      {
         newData[i] = data[i];
      }
   }

   newData[dataLen] = '\0';
   return newData;
}

cocochar_t* coco_string_create_lower(const cocochar_t* data)
{
   if (!data)
   {
      return nullptr;
   }
   int dataLen = COCO_Str::len(data);
   return coco_string_create_lower(data, 0, dataLen);
}

cocochar_t* coco_string_create_lower(const cocochar_t* data, int startIndex, int dataLen)
{
   if (!data)
   {
      return nullptr;
   }

   cocochar_t* newData = new cocochar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++)
   {
      cocochar_t ch = data[startIndex + i];
      if (('A' <= ch) && (ch <= 'Z'))
      {
         newData[i] = ch - ('A' - 'a');
      }
      else
      {
         newData[i] = ch;
      }
   }
   newData[dataLen] = '\0';
   return newData;
}

cocochar_t* coco_string_create_append(const cocochar_t* data1, const cocochar_t* data2)
{
   cocochar_t* data;
   int         data1Len = 0;
   int         data2Len = 0;

   if (data1)
   {
      data1Len = COCO_Str::len(data1);
   }
   if (data2)
   {
      data2Len = COCO_Str::len(data2);
   }

   data = new cocochar_t[data1Len + data2Len + 1];

   if (data1)
   {
      COCO_Str::cpy(data, data1);
   }
   if (data2)
   {
      COCO_Str::cpy(data + data1Len, data2);
   }

   data[data1Len + data2Len] = 0;

   return data;
}

cocochar_t* coco_string_create_append(const cocochar_t* target, const cocochar_t appendix)
{
   int         targetLen = coco_string_length(target);
   cocochar_t* data      = new cocochar_t[targetLen + 2];
   COCO_Str::ncpy(data, target, targetLen);
   data[targetLen]     = appendix;
   data[targetLen + 1] = 0;
   return data;
}

void coco_string_delete(cocochar_t*& data)
{
   delete[] data;
   data = nullptr;
}

int coco_string_length(const cocochar_t* data)
{
   if (data)
   {
      return COCO_Str::len(data);
   }
   return 0;
}

bool coco_string_endswith(const cocochar_t* data, const cocochar_t* end)
{
   int dataLen = COCO_Str::len(data);
   int endLen  = COCO_Str::len(end);
   return (endLen <= dataLen) && (COCO_Str::cmp(data + dataLen - endLen, end) == 0);
}

int coco_string_indexof(const cocochar_t* data, const cocochar_t value)
{
   const cocochar_t* chr = COCO_Str::chr(data, value);

   if (chr)
   {
      return ut::safe_cast<int>(chr - data);
   }
   return -1;
}

int coco_string_lastindexof(const cocochar_t* data, const cocochar_t value)
{
   const cocochar_t* chr = COCO_Str::rchr(data, value);

   if (chr)
   {
      return ut::safe_cast<int>(chr - data);
   }
   return -1;
}

void coco_string_merge(cocochar_t*& target, const cocochar_t* appendix)
{
   if (!appendix)
   {
      return;
   }
   cocochar_t* data = coco_string_create_append(target, appendix);
   delete[] target;
   target = data;
}

bool coco_string_equal(const cocochar_t* data1, const cocochar_t* data2)
{
   return COCO_Str::cmp(data1, data2) == 0;
}

int coco_string_compareto(const cocochar_t* data1, const cocochar_t* data2)
{
   return COCO_Str::cmp(data1, data2);
}

unsigned int coco_string_hash(const cocochar_t* data)
{
   unsigned int h = 0;
   if (!data)
   {
      return 0;
   }
   while (*data != 0)
   {
      h = (h * 7) ^ *data;
      ++data;
   }
   return h;
}

// string handling, ascii character
#if COCO_USE_WCHAR_T
cocochar_t* coco_string_create(const char* value)
{
   int len = 0;
   if (value)
   {
      len = strlen(value);
   }
   cocochar_t* data = new cocochar_t[len + 1];
   for (int i = 0; i < len; ++i)
   {
      data[i] = (cocochar_t)value[i];
   }
   data[len] = 0;
   return data;
}

void coco_string_delete(char*& data)
{
   delete[] data;
   data = nullptr;
}

#endif

char* coco_string_create_char(const cocochar_t* value)
{
   int   len = coco_string_length(value);
   char* res = new char[len + 1];
   for (int i = 0; i < len; ++i)
   {
      res[i] = (char)value[i];
   }
   res[len] = 0;
   return res;
}

Token::Token() {}

Token::~Token()
{
   coco_string_delete(val);
}

#if !COCO_USE_INLINE_BUFFER
Buffer::Buffer(FILE* s, bool isUserStream)
{
// ensure binary read on windows
#if _MSC_VER >= 1300
   _setmode(_fileno(s), _O_BINARY);
#endif
   stream             = s;
   this->isUserStream = isUserStream;
   if (CanSeek())
   {
      fseek(s, 0, SEEK_END);
      fileLen = ftell(s);
      fseek(s, 0, SEEK_SET);
      bufLen   = (fileLen < COCO_MAX_BUFFER_LENGTH) ? fileLen : COCO_MAX_BUFFER_LENGTH;
      bufStart = INT_MAX; // nothing in the buffer so far
   }
   else
   {
      fileLen = bufLen = bufStart = 0;
   }
   bufCapacity = (bufLen > 0) ? bufLen : COCO_MIN_BUFFER_LENGTH;
   buf         = new unsigned char[bufCapacity];
   if (fileLen > 0)
      SetPos(0); // setup  buffer to position 0 (start)
   else
      bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
   if (bufLen == fileLen && CanSeek())
      Close();
}

Buffer::Buffer(Buffer* b)
{
   buf          = b->buf;
   bufCapacity  = b->bufCapacity;
   b->buf       = nullptr;
   bufStart     = b->bufStart;
   bufLen       = b->bufLen;
   fileLen      = b->fileLen;
   bufPos       = b->bufPos;
   stream       = b->stream;
   b->stream    = nullptr;
   isUserStream = b->isUserStream;
}

Buffer::Buffer(const unsigned char* buf, int len)
{
   this->buf = new unsigned char[len];
   memcpy(this->buf, buf, len * sizeof(unsigned char));
   bufStart    = 0;
   bufCapacity = bufLen = len;
   fileLen              = len;
   bufPos               = 0;
   stream               = nullptr;
}

Buffer::~Buffer()
{
   Close();
   if (buf != nullptr)
   {
      delete[] buf;
      buf = nullptr;
   }
}

void Buffer::Close()
{
   if (!isUserStream && stream != nullptr)
   {
      fclose(stream);
      stream = nullptr;
   }
}

int Buffer::Read()
{
   if (bufPos < bufLen)
   {
      return buf[bufPos++];
   }
   else if (GetPos() < fileLen)
   {
      SetPos(GetPos()); // shift buffer start to Pos
      return buf[bufPos++];
   }
   else if ((stream != nullptr) && !CanSeek() && (ReadNextStreamChunk() > 0))
   {
      return buf[bufPos++];
   }
   else
   {
      return EoF;
   }
}

int Buffer::Peek()
{
   int curPos = GetPos();
   int ch     = Read();
   SetPos(curPos);
   return ch;
}

// beg .. begin, zero-based, inclusive, in byte
// end .. end, zero-based, exclusive, in byte
cocochar_t* Buffer::GetString(int beg, int end)
{
   int         len    = 0;
   cocochar_t* buffer = new cocochar_t[end - beg];
   int         oldPos = GetPos();
   SetPos(beg);
   while (GetPos() < end)
      buffer[len++] = (cocochar_t)Read();
   SetPos(oldPos);
   cocochar_t* res = coco_string_create(buffer, 0, len);
   coco_string_delete(buffer);
   return res;
}

int Buffer::GetPos()
{
   return bufPos + bufStart;
}

void Buffer::SetPos(int value)
{
   if ((value >= fileLen) && (stream != nullptr) && !CanSeek())
   {
      // Wanted position is after buffer and the stream
      // is not seek-able e.g. network or console,
      // thus we have to read the stream manually till
      // the wanted position is in sight.
      while ((value >= fileLen) && (ReadNextStreamChunk() > 0))
         ;
   }

   if ((value < 0) || (value > fileLen))
   {
      coco_printf(COCO_STR("--- buffer out of bounds access, position: %d\n"), value);
      exit(1);
   }

   if ((value >= bufStart) && (value < (bufStart + bufLen))) // already in buffer
   {
      bufPos = value - bufStart;
   }
   else if (stream != nullptr) // must be swapped in
   {
      fseek(stream, value, SEEK_SET);
      bufLen   = fread(buf, sizeof(unsigned char), bufCapacity, stream);
      bufStart = value;
      bufPos   = 0;
   }
   else
   {
      bufPos = fileLen - bufStart; // make Pos return fileLen
   }
}

// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk()
{
   int free = bufCapacity - bufLen;
   if (free == 0)
   {
      // in the case of a growing input stream
      // we can neither seek in the stream, nor can we
      // foresee the maximum length, thus we must adapt
      // the buffer size on demand.
      bufCapacity           = bufLen * 2;
      unsigned char* newBuf = new unsigned char[bufCapacity];
      memcpy(newBuf, buf, bufLen * sizeof(unsigned char));
      delete[] buf;
      buf  = newBuf;
      free = bufLen;
   }
   int read = fread(buf + bufLen, sizeof(unsigned char), free, stream);
   if (read > 0)
   {
      fileLen = bufLen = (bufLen + read);
      return read;
   }
   // end of stream reached
   return 0;
}

bool Buffer::CanSeek()
{
   return (stream != nullptr) && (ftell(stream) != -1);
}

int UTF8Buffer::Read()
{
   int ch;
   do
   {
      ch = Buffer::Read();
      // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
   } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EoF));
   if (ch < 128 || ch == EoF)
   {
      // nothing to do, first 127 chars are the same in ascii and utf8
      // 0xxxxxxx or end of file character
   }
   else if ((ch & 0xF0) == 0xF0)
   {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x07;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = Buffer::Read();
      int c3 = ch & 0x3F;
      ch     = Buffer::Read();
      int c4 = ch & 0x3F;
      ch     = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
   }
   else if ((ch & 0xE0) == 0xE0)
   {
      // 1110xxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x0F;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = Buffer::Read();
      int c3 = ch & 0x3F;
      ch     = (((c1 << 6) | c2) << 6) | c3;
   }
   else if ((ch & 0xC0) == 0xC0)
   {
      // 110xxxxx 10xxxxxx
      int c1 = ch & 0x1F;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = (c1 << 6) | c2;
   }
   return ch;
}
#endif

Scanner::Scanner(const unsigned char* buf, int len)
{
   buffer = new Buffer(buf, len);
   Init();
}

#if !COCO_USE_INLINE_BUFFER
Scanner::Scanner(const cocochar_t* fileName)
{
   FILE* stream;
   char* chFileName = coco_string_create_char(fileName);
   if ((stream = fopen(chFileName, "rb")) == nullptr)
   {
      { // RAII block
         auto out = ut::log::fatal() << "Cannot open file.";
         out.AddNote() << "File: " << fileName;
      }
      exit(1);
   }
   coco_string_delete(chFileName);
   buffer = new Buffer(stream, false);
   Init();
}

Scanner::Scanner(FILE* s)
{
   buffer = new Buffer(s, true);
   Init();
}
#endif

Scanner::~Scanner()
{
   char* cur = (char*)firstHeap;

   while (cur != nullptr)
   {
      cur = *(char**)(cur + COCO_HEAP_BLOCK_SIZE);
      free(firstHeap);
      firstHeap = cur;
   }
   delete[] tval;
   delete buffer;
}

void Scanner::Init()
{
   NewTokCb         = nullptr;
   mNewTokenDataPtr = nullptr;
   EOL              = '\n';
   eofSym           = 0;
   // ***Declarations Begin
   maxT  = 58;
   noSym = 58;
   int i;
   for (i = 65; i <= 90; ++i)
      start.set(i, 1);
   for (i = 95; i <= 95; ++i)
      start.set(i, 1);
   for (i = 97; i <= 122; ++i)
      start.set(i, 1);
   for (i = 48; i <= 57; ++i)
      start.set(i, 31);
   for (i = 34; i <= 34; ++i)
      start.set(i, 7);
   start.set(46, 32);
   start.set(39, 9);
   start.set(59, 13);
   start.set(40, 14);
   start.set(41, 15);
   start.set(61, 33);
   start.set(33, 43);
   start.set(62, 44);
   start.set(60, 45);
   start.set(43, 34);
   start.set(45, 35);
   start.set(38, 20);
   start.set(124, 22);
   start.set(125, 24);
   start.set(44, 25);
   start.set(42, 46);
   start.set(47, 47);
   start.set(123, 38);
   start.set(58, 39);
   start.set(94, 40);
   start.set(91, 41);
   start.set(93, 42);
   start.set(Buffer::EoF, -1);
   keywords.set("do", 26);
   keywords.set("if", 27);
   keywords.set("for", 28);
   keywords.set("foreach", 29);
   keywords.set("in", 30);
   keywords.set("else", 31);
   keywords.set("while", 32);
   keywords.set("break", 33);
   keywords.set("continue", 34);
   keywords.set("return", 35);
   keywords.set("null", 36);
   keywords.set("NULL", 37);
   keywords.set("true", 38);
   keywords.set("false", 39);
   keywords.set("string", 40);
   keywords.set("int", 41);
   keywords.set("double", 42);
   keywords.set("char", 43);
   keywords.set("bool", 44);
   keywords.set("global", 45);
   keywords.set("static", 46);
   keywords.set("extern", 47);

   // ***Declarations End
   tvalLength = 128;
   tval       = new cocochar_t[tvalLength]; // text of current token

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   heap      = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   firstHeap = heap;
   heapEnd   = (void**)(((char*)heap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd  = nullptr;
   heapTop   = heap;
   if (sizeof(Token) > COCO_HEAP_BLOCK_SIZE)
   {
      ut::log::fatal() << "Too small COCO_HEAP_BLOCK_SIZE.";
      exit(1);
   }

   pos     = -1;
   line    = 1;
   col     = 0;
   charPos = -1;
   oldEols = 0;
   NextCh();
#if !COCO_USE_INLINE_BUFFER
   if (ch == 0xEF)
   { // check optional byte order mark for UTF-8
      NextCh();
      int ch1 = ch;
      NextCh();
      int ch2 = ch;
      if (ch1 != 0xBB || ch2 != 0xBF)
      {
         ut::log::fatal() << "Illegal byte order mark at start of file.";
         exit(1);
      }
      Buffer* oldBuf = buffer;
      buffer         = new UTF8Buffer(buffer);
      col            = 0;
      charPos        = -1;
      delete oldBuf;
      oldBuf = nullptr;
      NextCh();
   }
#endif


   pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh()
{
   if (oldEols > 0)
   {
      ch = EOL;
      oldEols--;
   }
   else
   {
      pos = buffer->GetPos();
      // buffer reads unicode chars, if UTF8 has been detected
      ch = buffer->Read();
      col++;
      charPos++;
      // replace isolated '\r' by '\n' in order to make
      // eol handling uniform across Windows, Unix and Mac
      if (ch == '\r' && buffer->Peek() != '\n')
         ch = EOL;
      if (ch == EOL)
      {
         line++;
         col = 0;
      }
   }
}

void Scanner::AddCh()
{
   if (tlen >= tvalLength)
   {
      tvalLength *= 2;
      cocochar_t* newBuf = new cocochar_t[tvalLength];
      memcpy(newBuf, tval, tlen * sizeof(cocochar_t));
      delete[] tval;
      tval = newBuf;
   }
   if (ch != Buffer::EoF)
   {
      tval[tlen++] = ch;
      NextCh();
   }
}


bool Scanner::Comment0()
{
   int level = 1, line0 = line;
   NextCh();
   for (;;)
   {
      if (ch == 10)
      {
         level--;
         if (level == 0)
         {
            oldEols = line - line0;
            NextCh();
            return true;
         }
         NextCh();
      }
      else if (ch == buffer->EoF)
         return false;
      else
         NextCh();
   }
}

bool Scanner::Comment1()
{
   int level = 1, pos0 = pos, line0 = line, col0 = col, charPos0 = charPos;
   NextCh();
   if (ch == '/')
   {
      NextCh();
      for (;;)
      {
         if (ch == 10)
         {
            level--;
            if (level == 0)
            {
               oldEols = line - line0;
               NextCh();
               return true;
            }
            NextCh();
         }
         else if (ch == buffer->EoF)
            return false;
         else
            NextCh();
      }
   }
   else
   {
      buffer->SetPos(pos0);
      NextCh();
      line    = line0;
      col     = col0;
      charPos = charPos0;
   }
   return false;
}

bool Scanner::Comment2()
{
   int level = 1, pos0 = pos, line0 = line, col0 = col, charPos0 = charPos;
   NextCh();
   if (ch == '*')
   {
      NextCh();
      for (;;)
      {
         if (ch == '*')
         {
            NextCh();
            if (ch == '/')
            {
               level--;
               if (level == 0)
               {
                  oldEols = line - line0;
                  NextCh();
                  return true;
               }
               NextCh();
            }
         }
         else if (ch == '/')
         {
            NextCh();
            if (ch == '*')
            {
               level++;
               NextCh();
            }
         }
         else if (ch == buffer->EoF)
            return false;
         else
            NextCh();
      }
   }
   else
   {
      buffer->SetPos(pos0);
      NextCh();
      line    = line0;
      col     = col0;
      charPos = charPos0;
   }
   return false;
}


void Scanner::CreateHeapBlock()
{
   void* newHeap;
   char* cur = (char*)firstHeap;

   while (((char*)tokens < cur) || ((char*)tokens > (cur + COCO_HEAP_BLOCK_SIZE)))
   {
      cur = *((char**)(cur + COCO_HEAP_BLOCK_SIZE));
      free(firstHeap);
      firstHeap = cur;
   }

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   newHeap  = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   *heapEnd = newHeap;
   heapEnd  = (void**)(((char*)newHeap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd = nullptr;
   heap     = newHeap;
   heapTop  = heap;
}

Token* Scanner::CreateToken()
{
   Token* t;
   if (((char*)heapTop + (int)sizeof(Token)) >= (char*)heapEnd)
   {
      CreateHeapBlock();
   }
   t       = (Token*)heapTop;
   heapTop = (void*)((char*)heapTop + sizeof(Token));
   t->val  = nullptr;
   t->next = nullptr;
   return t;
}

void Scanner::AppendVal(Token* t)
{
   int reqMem = (tlen + 1) * sizeof(cocochar_t);
   if (((char*)heapTop + reqMem) >= (char*)heapEnd)
   {
      if (reqMem > COCO_HEAP_BLOCK_SIZE)
      {
         ut::log::fatal() << "Too long token value.";
         exit(1);
      }
      CreateHeapBlock();
   }
   t->val  = (cocochar_t*)heapTop;
   heapTop = (void*)((char*)heapTop + reqMem);

   COCO_Str::ncpy(t->val, tval, tlen);
   t->val[tlen] = '\0';
   t->len       = tlen;
   if (NewTokCb)
      (*NewTokCb)(t, mNewTokenDataPtr);
}

Token* Scanner::NextToken()
{
   while (ch == ' ' || (ch >= 9 && ch <= 10) || ch == 13)
      NextCh();
   if ((ch == '#' && Comment0()) || (ch == '/' && Comment1()) || (ch == '/' && Comment2()))
      return NextToken();
   int recKind = noSym;
   int recEnd  = pos;
   t           = CreateToken();
   t->pos      = pos;
   t->col      = col;
   t->line     = line;
   t->charPos  = charPos;
   int state   = start.state(ch);
   tlen        = 0;
   AddCh();

   switch (state)
   {
   case -1:
   {
      t->kind = eofSym;
      break;
   } // NextCh already done
   case 0:
   {
   case_0:
      if (recKind != noSym)
      {
         tlen = recEnd - t->pos;
         SetScannerBehindT();
      }
      t->kind = recKind;
      break;
   } // NextCh already done
   case 1:
   case_1:
      recEnd  = pos;
      recKind = 1;
      if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z'))
      {
         AddCh();
         goto case_1;
      }
      else
      {
         t->kind             = 1;
         cocochar_t* literal = coco_string_create(tval, 0, tlen);
         t->kind             = keywords.get(literal, t->kind);
         coco_string_delete(literal);
         break;
      }
   case 2:
   case_2:
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_4;
      }
      else if (ch == '+' || ch == '-')
      {
         AddCh();
         goto case_3;
      }
      else
      {
         goto case_0;
      }
   case 3:
   case_3:
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_4;
      }
      else
      {
         goto case_0;
      }
   case 4:
   case_4:
      recEnd  = pos;
      recKind = 3;
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_4;
      }
      else
      {
         t->kind = 3;
         break;
      }
   case 5:
   case_5:
      recEnd  = pos;
      recKind = 3;
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_5;
      }
      else if (ch == 'E' || ch == 'e')
      {
         AddCh();
         goto case_2;
      }
      else
      {
         t->kind = 3;
         break;
      }
   case 6:
   case_6:
      recEnd  = pos;
      recKind = 3;
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_6;
      }
      else if (ch == 'E' || ch == 'e')
      {
         AddCh();
         goto case_2;
      }
      else
      {
         t->kind = 3;
         break;
      }
   case 7:
   case_7:
      if (ch == '"')
      {
         AddCh();
         goto case_36;
      }
      else if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '!') || (ch >= '#' && ch <= '[') ||
               (ch >= ']' && ch <= 65535))
      {
         AddCh();
         goto case_7;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_8;
      }
      else
      {
         goto case_0;
      }
   case 8:
   case_8:
      if (ch == '"')
      {
         AddCh();
         goto case_37;
      }
      else if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '!') || (ch >= '#' && ch <= '[') ||
               (ch >= ']' && ch <= 65535))
      {
         AddCh();
         goto case_7;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_8;
      }
      else
      {
         goto case_0;
      }
   case 9:
      if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '&') || (ch >= '(' && ch <= '[') ||
          (ch >= ']' && ch <= 65535))
      {
         AddCh();
         goto case_10;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_11;
      }
      else
      {
         goto case_0;
      }
   case 10:
   case_10:
      if (ch == 39)
      {
         AddCh();
         goto case_12;
      }
      else
      {
         goto case_0;
      }
   case 11:
   case_11:
      if (ch == 39)
      {
         AddCh();
         goto case_10;
      }
      else
      {
         goto case_0;
      }
   case 12:
   case_12:
   {
      t->kind = 5;
      break;
   }
   case 13:
   {
      t->kind = 7;
      break;
   }
   case 14:
   {
      t->kind = 8;
      break;
   }
   case 15:
   {
      t->kind = 9;
      break;
   }
   case 16:
   case_16:
   {
      t->kind = 11;
      break;
   }
   case 17:
   case_17:
   {
      t->kind = 12;
      break;
   }
   case 18:
   case_18:
   {
      t->kind = 13;
      break;
   }
   case 19:
   case_19:
   {
      t->kind = 14;
      break;
   }
   case 20:
      if (ch == '&')
      {
         AddCh();
         goto case_21;
      }
      else
      {
         goto case_0;
      }
   case 21:
   case_21:
   {
      t->kind = 17;
      break;
   }
   case 22:
      if (ch == '|')
      {
         AddCh();
         goto case_23;
      }
      else
      {
         goto case_0;
      }
   case 23:
   case_23:
   {
      t->kind = 18;
      break;
   }
   case 24:
   {
      t->kind = 19;
      break;
   }
   case 25:
   {
      t->kind = 20;
      break;
   }
   case 26:
   case_26:
   {
      t->kind = 21;
      break;
   }
   case 27:
   case_27:
   {
      t->kind = 22;
      break;
   }
   case 28:
   case_28:
   {
      t->kind = 23;
      break;
   }
   case 29:
   case_29:
   {
      t->kind = 24;
      break;
   }
   case 30:
   case_30:
   {
      t->kind = 25;
      break;
   }
   case 31:
   case_31:
      recEnd  = pos;
      recKind = 2;
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_31;
      }
      else if (ch == '.')
      {
         AddCh();
         goto case_5;
      }
      else
      {
         t->kind = 2;
         break;
      }
   case 32:
      recEnd  = pos;
      recKind = 6;
      if ((ch >= '0' && ch <= '9'))
      {
         AddCh();
         goto case_6;
      }
      else
      {
         t->kind = 6;
         break;
      }
   case 33:
      recEnd  = pos;
      recKind = 10;
      if (ch == '=')
      {
         AddCh();
         goto case_16;
      }
      else
      {
         t->kind = 10;
         break;
      }
   case 34:
      recEnd  = pos;
      recKind = 15;
      if (ch == '=')
      {
         AddCh();
         goto case_26;
      }
      else
      {
         t->kind = 15;
         break;
      }
   case 35:
      recEnd  = pos;
      recKind = 16;
      if (ch == '=')
      {
         AddCh();
         goto case_27;
      }
      else if (ch == '>')
      {
         AddCh();
         goto case_30;
      }
      else
      {
         t->kind = 16;
         break;
      }
   case 36:
   case_36:
   {
      t->kind = 4;
      break;
   }
   case 37:
   case_37:
      recEnd  = pos;
      recKind = 4;
      if (ch == '"')
      {
         AddCh();
         goto case_36;
      }
      else if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '!') || (ch >= '#' && ch <= '[') ||
               (ch >= ']' && ch <= 65535))
      {
         AddCh();
         goto case_7;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_8;
      }
      else
      {
         t->kind = 4;
         break;
      }
   case 38:
   {
      t->kind = 50;
      break;
   }
   case 39:
   {
      t->kind = 51;
      break;
   }
   case 40:
   {
      t->kind = 52;
      break;
   }
   case 41:
   {
      t->kind = 56;
      break;
   }
   case 42:
   {
      t->kind = 57;
      break;
   }
   case 43:
      recEnd  = pos;
      recKind = 55;
      if (ch == '=')
      {
         AddCh();
         goto case_17;
      }
      else
      {
         t->kind = 55;
         break;
      }
   case 44:
      recEnd  = pos;
      recKind = 49;
      if (ch == '=')
      {
         AddCh();
         goto case_18;
      }
      else
      {
         t->kind = 49;
         break;
      }
   case 45:
      recEnd  = pos;
      recKind = 48;
      if (ch == '=')
      {
         AddCh();
         goto case_19;
      }
      else
      {
         t->kind = 48;
         break;
      }
   case 46:
      recEnd  = pos;
      recKind = 53;
      if (ch == '=')
      {
         AddCh();
         goto case_28;
      }
      else
      {
         t->kind = 53;
         break;
      }
   case 47:
      recEnd  = pos;
      recKind = 54;
      if (ch == '=')
      {
         AddCh();
         goto case_29;
      }
      else
      {
         t->kind = 54;
         break;
      }
   }
   AppendVal(t);
   return t;
}

void Scanner::SetScannerBehindT()
{
   buffer->SetPos(t->pos);
   NextCh();
   line    = t->line;
   col     = t->col;
   charPos = t->charPos;
   for (int i = 0; i < tlen; i++)
      NextCh();
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan()
{
   if (tokens->next == nullptr)
   {
      return pt = tokens = NextToken();
   }
   else
   {
      pt = tokens = tokens->next;
      return tokens;
   }
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek()
{
   do
   {
      if (pt->next == nullptr)
      {
         pt->next = NextToken();
      }
      pt = pt->next;
   } while (pt->kind > maxT); // skip pragmas

   return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek()
{
   pt = tokens;
}

} // namespace UtScriptLanguage
