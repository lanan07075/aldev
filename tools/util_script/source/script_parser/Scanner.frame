// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Scanner.h Specification
-----------------------------------------------------------------------*/

-->begin
#if !defined(-->prefixCOCO_SCANNER_H__)
#define -->prefixCOCO_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "UtLog.hpp"

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

struct COCO_Str {
   typedef char char_type;
   static char* ncpy(char* dest, const char* src, size_t n) { return strncpy(dest, src, n); }
   static char* cpy(char* dest, const char* src) { return strcpy(dest, src); }
   static int len(const char* s) { return (int)strlen(s); }
   static int cmp(const char* s1, const char* s2) { return strcmp(s1,s2); }
   static const char* rchr(const char* wcs, char wc) { return strrchr(wcs, wc); }
   static char* rchr(char* wcs, char wc) { return strrchr(wcs, wc); }
   static const char* chr(const char* wcs, char wc) { return strchr(wcs, wc); }
   static char* chr(char* wcs, char wc) { return strchr(wcs, wc); }
};

using cocochar_t = COCO_Str::char_type;

#define COCO_WCHAR_MAX 65535
#define COCO_MIN_BUFFER_LENGTH 1024
#define COCO_MAX_BUFFER_LENGTH (64*COCO_MIN_BUFFER_LENGTH)
#define COCO_HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR COCO_STR(':')

-->namespace_open
// string handling, wide character
cocochar_t* coco_string_create(const cocochar_t* value);
cocochar_t* coco_string_create(const cocochar_t* value, int startIndex);
cocochar_t* coco_string_create(const cocochar_t* value, int startIndex, int length);
cocochar_t* coco_string_create_upper(const cocochar_t* data);
cocochar_t* coco_string_create_lower(const cocochar_t* data);
cocochar_t* coco_string_create_lower(const cocochar_t* data, int startIndex, int dataLen);
cocochar_t* coco_string_create_append(const cocochar_t* data1, const cocochar_t* data2);
cocochar_t* coco_string_create_append(const cocochar_t* data, const cocochar_t value);
void  coco_string_delete(cocochar_t* &data);
int   coco_string_length(const cocochar_t* data);
bool  coco_string_endswith(const cocochar_t* data, const cocochar_t* value);
int   coco_string_indexof(const cocochar_t* data, const cocochar_t value);
int   coco_string_lastindexof(const cocochar_t* data, const cocochar_t value);
void  coco_string_merge(cocochar_t* &data, const cocochar_t* value);
bool  coco_string_equal(const cocochar_t* data1, const cocochar_t* data2);
int   coco_string_compareto(const cocochar_t* data1, const cocochar_t* data2);
unsigned int coco_string_hash(const cocochar_t* data);

// string handling, ascii character
#if COCO_USE_WCHAR_T
cocochar_t* coco_string_create(const char* value);
void  coco_string_delete(char* &data);
#endif
char* coco_string_create_char(const cocochar_t* value);

class Token
{
   public:
      Token();
      virtual ~Token();

      int kind { 0 };     // token kind
      int pos { 0 };      // token position in bytes in the source text (starting at 0)
      int charPos { 0 };  // token position in characters in the source text (starting at 0)
      int col { 0 };      // token column (starting at 1)
      int line { 0 };     // token line (starting at 1)
      cocochar_t* val { nullptr }; // token value
      Token* next { nullptr };     // ML 2005-03-11 Peek tokens are kept in linked list
      int    len { 0 };

};
#define COCO_USE_INLINE_BUFFER 1
#if COCO_USE_INLINE_BUFFER
// Support for utf8 increases parse time, particularly because Read() is virtual.
// This is an alternate implementation of Buffer which does not have virtual methods,
// and only supports in-memory multi-byte files
class Buffer
{
   public:
      static const int EoF = COCO_WCHAR_MAX + 1;

      Buffer(const Buffer& aSrc) = delete;
      Buffer& operator=(const Buffer& aRhs) = delete;

      Buffer(const unsigned char* buf, int len)
      {
         this->buf = new unsigned char[len];
         memcpy(this->buf, buf, len*sizeof(unsigned char));
         bufCapacity = bufLen = len;
         fileLen = len;
         bufPos = 0;
      }
      Buffer(Buffer *b);
      ~Buffer()
      {
         if (buf != nullptr) {
            delete [] buf;
            buf = nullptr;
         }
      }

      void Close() {}
      int Read()
      {
         if (bufPos < bufLen) {
            return buf[bufPos++];
         } else {
            return EoF;
         }
      }
      int Peek()
      {
         int curPos = GetPos();
         int ch = Read();
         SetPos(curPos);
         return ch;
      }

      // beg .. begin, zero-based, inclusive, in byte
      // end .. end, zero-based, exclusive, in byte
      cocochar_t* GetString(int beg, int end)
      {
         int len = 0;
         cocochar_t* buffer = new cocochar_t[end - beg];
         int oldPos = GetPos();
         SetPos(beg);
         while (GetPos() < end) buffer[len++] = (cocochar_t) Read();
         SetPos(oldPos);
         cocochar_t *res = coco_string_create(buffer, 0, len);
         coco_string_delete(buffer);
         return res;
      }
      int GetPos()
      {
         return bufPos;
      }
      void SetPos(int value)
      {
         if ((value < 0) || (value > fileLen))
         {
            { // RAII block
               auto out = ut::log::fatal() << "Buffer out-of-bounds access.";
               out.AddNote() << "Position: " << value;
            }
            exit(1);
         }
         if ((value >= 0) && (value < (bufLen))) // already in buffer
         {
            bufPos = value;
         }
         else
         {
            bufPos = fileLen; // make Pos return fileLen
         }
      }

   private:
      unsigned char* buf;
      int bufCapacity;    // capacity of buf
      int bufLen;         // length of buffer
      int fileLen;        // length of input stream (may change if the stream is no file)
      int bufPos;         // current position in buffer
};

#else
class Buffer
{
   // This Buffer supports the following cases:
   // 1) seekable stream (file)
   //    a) whole stream in buffer
   //    b) part of stream in buffer
   // 2) non seekable stream (network, console)
   public:
      static const int EoF = COCO_WCHAR_MAX + 1;

      Buffer(const Buffer& aSrc) = delete;
      Buffer& operator=(const Buffer& aRhs) = delete;

      Buffer(FILE* s, bool isUserStream);
      Buffer(const unsigned char* buf, int len);
      Buffer(Buffer *b);
      virtual ~Buffer();

      virtual void Close();
      virtual int Read();
      virtual int Peek();
      virtual cocochar_t* GetString(int beg, int end);
      virtual int GetPos();
      virtual void SetPos(int value);

   private:
      unsigned char *buf; // input buffer
      int bufCapacity;    // capacity of buf
      int bufStart;       // position of first byte in buffer relative to input stream
      int bufLen;         // length of buffer
      int fileLen;        // length of input stream (may change if the stream is no file)
      int bufPos;         // current position in buffer
      FILE* stream;       // input stream (seekable)
      bool isUserStream;  // was the stream opened by the user?

      int ReadNextStreamChunk();
      bool CanSeek();     // true if stream can be seeked otherwise false
};

class UTF8Buffer : public Buffer
{
   public:
      UTF8Buffer(Buffer *b) : Buffer(b) {};
      virtual int Read();
};
#endif

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates
{
   public:
      StartStates() { tab = new Elem*[128]; memset(tab, 0, 128 * sizeof(Elem*)); }
      virtual ~StartStates()
      {
         for (int i = 0; i < 128; ++i)
         {
            Elem *e = tab[i];
            while (e != nullptr)
            {
               Elem *next = e->next;
               delete e;
               e = next;
            }
         }
         delete [] tab;
      }

      StartStates(const StartStates& aSrc) = delete;
      StartStates& operator=(const StartStates& aRhs) = delete;

      void set(int key, int val)
      {
         Elem *e = new Elem(key, val);
         int k = ((unsigned int) key) % 128;
         e->next = tab[k]; tab[k] = e;
      }

      int state(int key)
      {
         Elem *e = tab[((unsigned int) key) % 128];
         while (e != nullptr && e->key != key) e = e->next;
         return e == nullptr ? 0 : e->val;
      }

   private:
      class Elem
      {
         public:
            int key, val;
            Elem *next;
            Elem(int key, int val) { this->key = key; this->val = val; next = nullptr; }
      };

      Elem **tab;

};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap
{
   public:
      KeywordMap() { tab = new Elem*[128]; memset(tab, 0, 128 * sizeof(Elem*)); }
      virtual ~KeywordMap()
      {
         for (int i = 0; i < 128; ++i)
         {
            Elem *e = tab[i];
            while (e != nullptr)
            {
               Elem *next = e->next;
               delete e;
               e = next;
            }
         }
         delete [] tab;
      }

      KeywordMap(const KeywordMap& aSrc) = delete;
      KeywordMap& operator=(const KeywordMap& aRhs) = delete;

      void set(const cocochar_t *key, int val)
      {
         Elem *e = new Elem(key, val);
         unsigned int k = coco_string_hash(key) % 128;
         e->next = tab[k]; tab[k] = e;
      }

      int get(const cocochar_t *key, int defaultVal)
      {
         Elem *e = tab[coco_string_hash(key) % 128];
         while (e != nullptr && !coco_string_equal(e->key, key)) e = e->next;
         return e == nullptr ? defaultVal : e->val;
      }

   private:
      class Elem
      {
         public:
            cocochar_t *key;
            int val;
            Elem *next;
            Elem(const cocochar_t *key, int val) { this->key = coco_string_create(key); this->val = val; next = nullptr; }
            virtual ~Elem() { coco_string_delete(key); }
      };

      Elem **tab;

};

class Scanner
{
public:
   Scanner(const unsigned char* buf, int len);
#if !COCO_USE_INLINE_BUFFER
   Scanner(const cocochar_t* fileName);
   Scanner(FILE* s);
#endif
   virtual ~Scanner();

   Scanner(const Scanner& aSrc) = delete;
   Scanner& operator=(const Scanner& aRhs) = delete;

   Token* Scan();
   Token* Peek();
   void ResetPeek();

   void (*NewTokCb)(Token*, void*);
   void*             mNewTokenDataPtr;

   Buffer*  buffer { nullptr };   // scanner buffer

private:
   void* firstHeap;
   void* heap;
   void* heapTop;
   void** heapEnd;

   unsigned char EOL;
   int eofSym { 0 };
   int noSym { 0 };
   int maxT { 0 };
   StartStates start;
   KeywordMap keywords;

   Token* t { nullptr };         // current token
   cocochar_t* tval { nullptr }; // text of current token
   int tvalLength { 0 };         // length of text of current token
   int tlen { 0 };               // length of current token

   Token* tokens { nullptr };    // list of tokens already peeked (first token is a dummy)
   Token* pt { nullptr };        // current peek token

   int ch { 0 };                 // current input character
// ***Casing Begin
-->casing0
// ***Casing End
   int pos { 0 };                // byte position of current character
   int charPos { 0 };            // position by unicode characters starting with 0
   int line { 0 };               // line number of current character
   int col { 0 };                // column number of current character
   int oldEols { 0 };            // EOLs that appeared in a comment;

   void CreateHeapBlock();
   Token* CreateToken();
   void AppendVal(Token *t);
   void SetScannerBehindT();

   void Init();
   void NextCh();
   void AddCh();
   Token* NextToken();

// ***Comments Begin
-->commentsheader
// ***Comments End

}; // end Scanner

-->namespace_close
#endif

-->implementation

/*----------------------------------------------------------------------
Scanner.cpp Specification
-----------------------------------------------------------------------*/

-->begin
#include "Scanner.h"

#include "UtCast.hpp"

-->namespace_open
// string handling, wide character

cocochar_t* coco_string_create(const cocochar_t* value)
{
   return coco_string_create(value, 0);
}

cocochar_t* coco_string_create(const cocochar_t* value, int startIndex)
{
   int len = 0;

   if (value)
   {
      int valueLen = COCO_Str::len(value);
      len = valueLen - startIndex;
   }

   return coco_string_create(value, startIndex, len);
}

cocochar_t* coco_string_create(const cocochar_t* value, int startIndex, int length)
{
   int len = 0;
   cocochar_t* data;

   if (value) { len = length; }
   data = new cocochar_t[len + 1];
   COCO_Str::ncpy(data, &(value[startIndex]), len);
   data[len] = 0;

   return data;
}

cocochar_t* coco_string_create_upper(const cocochar_t* data)
{
   if (!data) { return nullptr; }

   int dataLen = 0;
   if (data) { dataLen = COCO_Str::len(data); }

   cocochar_t *newData = new cocochar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++)
   {
      if (('a' <= data[i]) && (data[i] <= 'z'))
      {
         newData[i] = data[i] + ('A' - 'a');
      }
      else { newData[i] = data[i]; }
   }

   newData[dataLen] = '\0';
   return newData;
}

cocochar_t* coco_string_create_lower(const cocochar_t* data)
{
   if (!data) { return nullptr; }
   int dataLen = COCO_Str::len(data);
   return coco_string_create_lower(data, 0, dataLen);
}

cocochar_t* coco_string_create_lower(const cocochar_t* data, int startIndex, int dataLen)
{
   if (!data) { return nullptr; }

   cocochar_t* newData = new cocochar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++) {
      cocochar_t ch = data[startIndex + i];
      if (('A' <= ch) && (ch <= 'Z'))
      {
         newData[i] = ch - ('A' - 'a');
      }
      else { newData[i] = ch; }
   }
   newData[dataLen] = '\0';
   return newData;
}

cocochar_t* coco_string_create_append(const cocochar_t* data1, const cocochar_t* data2)
{
   cocochar_t* data;
   int data1Len = 0;
   int data2Len = 0;

   if (data1) { data1Len = COCO_Str::len(data1); }
   if (data2) {data2Len = COCO_Str::len(data2); }

   data = new cocochar_t[data1Len + data2Len + 1];

   if (data1) { COCO_Str::cpy(data, data1); }
   if (data2) { COCO_Str::cpy(data + data1Len, data2); }

   data[data1Len + data2Len] = 0;

   return data;
}

cocochar_t* coco_string_create_append(const cocochar_t* target, const cocochar_t appendix)
{
   int targetLen = coco_string_length(target);
   cocochar_t* data = new cocochar_t[targetLen + 2];
   COCO_Str::ncpy(data, target, targetLen);
   data[targetLen] = appendix;
   data[targetLen + 1] = 0;
   return data;
}

void coco_string_delete(cocochar_t* &data)
{
   delete [] data;
   data = nullptr;
}

int coco_string_length(const cocochar_t* data)
{
   if (data) { return COCO_Str::len(data); }
   return 0;
}

bool coco_string_endswith(const cocochar_t* data, const cocochar_t* end)
{
   int dataLen = COCO_Str::len(data);
   int endLen = COCO_Str::len(end);
   return (endLen <= dataLen) && (COCO_Str::cmp(data + dataLen - endLen, end) == 0);
}

int coco_string_indexof(const cocochar_t* data, const cocochar_t value)
{
   const cocochar_t* chr = COCO_Str::chr(data, value);

   if (chr) { return ut::safe_cast<int>(chr-data); }
   return -1;
}

int coco_string_lastindexof(const cocochar_t* data, const cocochar_t value)
{
   const cocochar_t* chr = COCO_Str::rchr(data, value);

   if (chr) { return ut::safe_cast<int>(chr-data); }
   return -1;
}

void coco_string_merge(cocochar_t* &target, const cocochar_t* appendix)
{
   if (!appendix) { return; }
   cocochar_t* data = coco_string_create_append(target, appendix);
   delete [] target;
   target = data;
}

bool coco_string_equal(const cocochar_t* data1, const cocochar_t* data2)
{
   return COCO_Str::cmp( data1, data2 ) == 0;
}

int coco_string_compareto(const cocochar_t* data1, const cocochar_t* data2)
{
   return COCO_Str::cmp(data1, data2);
}

unsigned int coco_string_hash(const cocochar_t* data)
{
   unsigned int h = 0;
   if (!data) { return 0; }
   while (*data != 0)
   {
      h = (h * 7) ^ *data;
      ++data;
   }
   return h;
}

// string handling, ascii character
#if COCO_USE_WCHAR_T
cocochar_t* coco_string_create(const char* value)
{
   int len = 0;
   if (value) { len = strlen(value); }
   cocochar_t* data = new cocochar_t[len + 1];
   for (int i = 0; i < len; ++i) { data[i] = (cocochar_t) value[i]; }
   data[len] = 0;
   return data;
}

void coco_string_delete(char* &data)
{
   delete [] data;
   data = nullptr;
}

#endif

char* coco_string_create_char(const cocochar_t *value)
{
   int len = coco_string_length(value);
   char *res = new char[len + 1];
   for (int i = 0; i < len; ++i) { res[i] = (char) value[i]; }
   res[len] = 0;
   return res;
}

Token::Token()
{
}

Token::~Token()
{
   coco_string_delete(val);
}

#if !COCO_USE_INLINE_BUFFER
Buffer::Buffer(FILE* s, bool isUserStream)
{
// ensure binary read on windows
#if _MSC_VER >= 1300
   _setmode(_fileno(s), _O_BINARY);
#endif
   stream = s; this->isUserStream = isUserStream;
   if (CanSeek())
   {
      fseek(s, 0, SEEK_END);
      fileLen = ftell(s);
      fseek(s, 0, SEEK_SET);
      bufLen = (fileLen < COCO_MAX_BUFFER_LENGTH) ? fileLen : COCO_MAX_BUFFER_LENGTH;
      bufStart = INT_MAX; // nothing in the buffer so far
   }
   else
   {
      fileLen = bufLen = bufStart = 0;
   }
   bufCapacity = (bufLen>0) ? bufLen : COCO_MIN_BUFFER_LENGTH;
   buf = new unsigned char[bufCapacity];
   if (fileLen > 0) SetPos(0);          // setup  buffer to position 0 (start)
   else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
   if (bufLen == fileLen && CanSeek()) Close();
}

Buffer::Buffer(Buffer *b)
{
   buf = b->buf;
   bufCapacity = b->bufCapacity;
   b->buf = nullptr;
   bufStart = b->bufStart;
   bufLen = b->bufLen;
   fileLen = b->fileLen;
   bufPos = b->bufPos;
   stream = b->stream;
   b->stream = nullptr;
   isUserStream = b->isUserStream;
}

Buffer::Buffer(const unsigned char* buf, int len)
{
   this->buf = new unsigned char[len];
   memcpy(this->buf, buf, len*sizeof(unsigned char));
   bufStart = 0;
   bufCapacity = bufLen = len;
   fileLen = len;
   bufPos = 0;
   stream = nullptr;
}

Buffer::~Buffer()
{
   Close();
   if (buf != nullptr)
   {
      delete [] buf;
      buf = nullptr;
   }
}

void Buffer::Close()
{
   if (!isUserStream && stream != nullptr)
   {
      fclose(stream);
      stream = nullptr;
   }
}

int Buffer::Read()
{
   if (bufPos < bufLen)
   {
      return buf[bufPos++];
   }
   else if (GetPos() < fileLen)
   {
      SetPos(GetPos()); // shift buffer start to Pos
      return buf[bufPos++];
   }
   else if ((stream != nullptr) && !CanSeek() && (ReadNextStreamChunk() > 0))
   {
      return buf[bufPos++];
   }
   else
   {
      return EoF;
   }
}

int Buffer::Peek()
{
   int curPos = GetPos();
   int ch = Read();
   SetPos(curPos);
   return ch;
}

// beg .. begin, zero-based, inclusive, in byte
// end .. end, zero-based, exclusive, in byte
cocochar_t* Buffer::GetString(int beg, int end)
{
   int len = 0;
   cocochar_t* buffer = new cocochar_t[end - beg];
   int oldPos = GetPos();
   SetPos(beg);
   while (GetPos() < end) buffer[len++] = (cocochar_t) Read();
   SetPos(oldPos);
   cocochar_t *res = coco_string_create(buffer, 0, len);
   coco_string_delete(buffer);
   return res;
}

int Buffer::GetPos()
{
   return bufPos + bufStart;
}

void Buffer::SetPos(int value)
{
   if ((value >= fileLen) && (stream != nullptr) && !CanSeek())
   {
      // Wanted position is after buffer and the stream
      // is not seek-able e.g. network or console,
      // thus we have to read the stream manually till
      // the wanted position is in sight.
      while ((value >= fileLen) && (ReadNextStreamChunk() > 0));
   }

   if ((value < 0) || (value > fileLen))
   {
      coco_printf(COCO_STR("--- buffer out of bounds access, position: %d\n"), value);
      exit(1);
   }

   if ((value >= bufStart) && (value < (bufStart + bufLen)))  // already in buffer
   {
      bufPos = value - bufStart;
   }
   else if (stream != nullptr) // must be swapped in
   {
      fseek(stream, value, SEEK_SET);
      bufLen = fread(buf, sizeof(unsigned char), bufCapacity, stream);
      bufStart = value; bufPos = 0;
   }
   else
   {
      bufPos = fileLen - bufStart; // make Pos return fileLen
   }
}

// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk()
{
   int free = bufCapacity - bufLen;
   if (free == 0)
   {
      // in the case of a growing input stream
      // we can neither seek in the stream, nor can we
      // foresee the maximum length, thus we must adapt
      // the buffer size on demand.
      bufCapacity = bufLen * 2;
      unsigned char *newBuf = new unsigned char[bufCapacity];
      memcpy(newBuf, buf, bufLen*sizeof(unsigned char));
      delete [] buf;
      buf = newBuf;
      free = bufLen;
   }
   int read = fread(buf + bufLen, sizeof(unsigned char), free, stream);
   if (read > 0)
   {
      fileLen = bufLen = (bufLen + read);
      return read;
   }
   // end of stream reached
   return 0;
}

bool Buffer::CanSeek()
{
   return (stream != nullptr) && (ftell(stream) != -1);
}

int UTF8Buffer::Read()
{
   int ch;
   do
   {
      ch = Buffer::Read();
      // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
   } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EoF));
   if (ch < 128 || ch == EoF)
   {
      // nothing to do, first 127 chars are the same in ascii and utf8
      // 0xxxxxxx or end of file character
   }
   else if ((ch & 0xF0) == 0xF0)
   {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x07; ch = Buffer::Read();
      int c2 = ch & 0x3F; ch = Buffer::Read();
      int c3 = ch & 0x3F; ch = Buffer::Read();
      int c4 = ch & 0x3F;
      ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
   }
   else if ((ch & 0xE0) == 0xE0)
   {
      // 1110xxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x0F; ch = Buffer::Read();
      int c2 = ch & 0x3F; ch = Buffer::Read();
      int c3 = ch & 0x3F;
      ch = (((c1 << 6) | c2) << 6) | c3;
   }
   else if ((ch & 0xC0) == 0xC0)
   {
      // 110xxxxx 10xxxxxx
      int c1 = ch & 0x1F; ch = Buffer::Read();
      int c2 = ch & 0x3F;
      ch = (c1 << 6) | c2;
   }
   return ch;
}
#endif

Scanner::Scanner(const unsigned char* buf, int len)
{
   buffer = new Buffer(buf, len);
   Init();
}

#if !COCO_USE_INLINE_BUFFER
Scanner::Scanner(const cocochar_t* fileName)
{
   FILE* stream;
   char *chFileName = coco_string_create_char(fileName);
   if ((stream = fopen(chFileName, "rb")) == nullptr)
   {
      { // RAII block
         auto out = ut::log::fatal() << "Cannot open file.";
         out.AddNote() << "File: " << fileName;
      }
      exit(1);
   }
   coco_string_delete(chFileName);
   buffer = new Buffer(stream, false);
   Init();
}

Scanner::Scanner(FILE* s)
{
   buffer = new Buffer(s, true);
   Init();
}
#endif

Scanner::~Scanner()
{
   char* cur = (char*) firstHeap;

   while(cur != nullptr)
   {
      cur = *(char**) (cur + COCO_HEAP_BLOCK_SIZE);
      free(firstHeap);
      firstHeap = cur;
   }
   delete [] tval;
   delete buffer;
}

void Scanner::Init()
{
   NewTokCb = nullptr;
   mNewTokenDataPtr = nullptr;
   EOL    = '\n';
   eofSym = 0;
// ***Declarations Begin
-->declarations
// ***Declarations End
   tvalLength = 128;
   tval = new cocochar_t[tvalLength]; // text of current token

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   heap = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   firstHeap = heap;
   heapEnd = (void**) (((char*) heap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd = nullptr;
   heapTop = heap;
   if (sizeof(Token) > COCO_HEAP_BLOCK_SIZE)
   {
      ut::log::fatal() << "Too small COCO_HEAP_BLOCK_SIZE.";
      exit(1);
   }

   pos = -1; line = 1; col = 0; charPos = -1;
   oldEols = 0;
   NextCh();
#if !COCO_USE_INLINE_BUFFER
   if (ch == 0xEF)
   { // check optional byte order mark for UTF-8
      NextCh(); int ch1 = ch;
      NextCh(); int ch2 = ch;
      if (ch1 != 0xBB || ch2 != 0xBF)
      {
         ut::log::fatal() << "Illegal byte order mark at start of file.";
         exit(1);
      }
      Buffer *oldBuf = buffer;
      buffer = new UTF8Buffer(buffer); col = 0; charPos = -1;
      delete oldBuf; oldBuf = nullptr;
      NextCh();
   }
#endif

-->initialization
   pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh()
{
   if (oldEols > 0)
   {
      ch = EOL; oldEols--;
   }
   else
   {
      pos = buffer->GetPos();
      // buffer reads unicode chars, if UTF8 has been detected
      ch = buffer->Read(); col++; charPos++;
      // replace isolated '\r' by '\n' in order to make
      // eol handling uniform across Windows, Unix and Mac
      if (ch == '\r' && buffer->Peek() != '\n') ch = EOL;
      if (ch == EOL) { line++; col = 0; }
   }
-->casing1
}

void Scanner::AddCh()
{
   if (tlen >= tvalLength)
   {
      tvalLength *= 2;
      cocochar_t *newBuf = new cocochar_t[tvalLength];
      memcpy(newBuf, tval, tlen*sizeof(cocochar_t));
      delete [] tval;
      tval = newBuf;
   }
   if (ch != Buffer::EoF)
   {
-->casing2
      NextCh();
   }
}

-->comments

void Scanner::CreateHeapBlock()
{
   void* newHeap;
   char* cur = (char*) firstHeap;

   while(((char*) tokens < cur) || ((char*) tokens > (cur + COCO_HEAP_BLOCK_SIZE)))
   {
      cur = *((char**) (cur + COCO_HEAP_BLOCK_SIZE));
      free(firstHeap);
      firstHeap = cur;
   }

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   newHeap = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   *heapEnd = newHeap;
   heapEnd = (void**) (((char*) newHeap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd = nullptr;
   heap = newHeap;
   heapTop = heap;
}

Token* Scanner::CreateToken()
{
   Token *t;
   if (((char*) heapTop + (int) sizeof(Token)) >= (char*) heapEnd)
   {
      CreateHeapBlock();
   }
   t = (Token*) heapTop;
   heapTop = (void*) ((char*) heapTop + sizeof(Token));
   t->val = nullptr;
   t->next = nullptr;
   return t;
}

void Scanner::AppendVal(Token *t)
{
   int reqMem = (tlen + 1) * sizeof(cocochar_t);
   if (((char*) heapTop + reqMem) >= (char*) heapEnd)
   {
      if (reqMem > COCO_HEAP_BLOCK_SIZE)
      {
         ut::log::fatal() << "Too long token value.";
         exit(1);
      }
      CreateHeapBlock();
   }
   t->val = (cocochar_t*) heapTop;
   heapTop = (void*) ((char*) heapTop + reqMem);

   COCO_Str::ncpy(t->val, tval, tlen);
   t->val[tlen] = '\0';
   t->len = tlen;
   if (NewTokCb) (*NewTokCb)(t, mNewTokenDataPtr);
}

Token* Scanner::NextToken()
{
   while (ch == ' ' ||
-->scan1
   ) NextCh();
-->scan2
   int recKind = noSym;
   int recEnd = pos;
   t = CreateToken();
   t->pos = pos; t->col = col; t->line = line; t->charPos = charPos;
   int state = start.state(ch);
   tlen = 0; AddCh();

   switch (state)
   {
      case -1: { t->kind = eofSym; break; } // NextCh already done
      case 0: {
         case_0:
         if (recKind != noSym) {
            tlen = recEnd - t->pos;
            SetScannerBehindT();
         }
         t->kind = recKind; break;
      } // NextCh already done
-->scan3
   }
   AppendVal(t);
   return t;
}

void Scanner::SetScannerBehindT()
{
   buffer->SetPos(t->pos);
   NextCh();
   line = t->line; col = t->col; charPos = t->charPos;
   for (int i = 0; i < tlen; i++) NextCh();
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan()
{
   if (tokens->next == nullptr)
   {
      return pt = tokens = NextToken();
   }
   else
   {
      pt = tokens = tokens->next;
      return tokens;
   }
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek()
{
   do
   {
      if (pt->next == nullptr) {
         pt->next = NextToken();
      }
      pt = pt->next;
   } while (pt->kind > maxT); // skip pragmas

   return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek()
{
   pt = tokens;
}

-->namespace_close
