// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin
#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef
#include "Scanner.h"

-->namespace_open
class Errors
{
   public:
      int count { 0 };                                   // number of errors detected

      Errors() = default;
      virtual ~Errors() = default;

      static char* GetStaticError(int aId);

      virtual void SynErr(Token* tok, int n);
      virtual void Error(Token* tok, const cocochar_t* s);
      virtual void Warning(Token* tok, const cocochar_t* s);
      virtual void Warning(const cocochar_t* s);
      virtual void Exception(const cocochar_t* s);

}; // Errors

class Parser
{
public:

// ***Constants Header Begin
-->constantsheader
// ***Constants Header End

// ***Declarations Begin - This section is a direct copy from .atg file
-->declarations
// ***Declarations End

   // Constructor and destructor
   explicit Parser(Scanner* aScannerPtr);
   Parser(const Parser& aSrc) = delete;
   Parser& operator=(const Parser& aRhs) = delete;
   virtual ~Parser();

   void InitParse();
   void Parse();

   void SemErr(const cocochar_t* msg);

   Scanner* mScannerPtr { nullptr };     // the scanner of this parser
   Errors*  mErrorsPtr  { nullptr };     // error message stream

   // Not following standard in order to keep actions brief
   Token*   t  { nullptr };              // last recognized token
   Token*   la { nullptr };              // lookahead token; not yet parsed

// ***Production Header Begin
-->productionsheader
// ***Production Header End

private:

   void SynErr(int n);
   void Get();
   void Expect(int n);
   bool StartOf(int s);
   void ExpectWeak(int n, int follow);
   bool WeakSeparator(int n, int syFol, int repFol);

   Token* mDummyTokenPtr { nullptr };
   int    mErrDist { 2 };
   int    mMinErrDist { 2 };

}; // end Parser

-->namespace_close
#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin
#include "Parser.h"

-->namespace_open
void Parser::SynErr(int n)
{
   if (mErrDist >= mMinErrDist) mErrorsPtr->SynErr(la, n);
   if (mErrDist == 0) Get();
   mErrDist = 0;
}

void Parser::SemErr(const cocochar_t* msg)
{
   if (mErrDist >= mMinErrDist) mErrorsPtr->Error(t, msg);
   mErrDist = 0;
}

void Parser::Get()
{
   for (;;)
   {
      t = la;
      la = mScannerPtr->Scan();
      if (la->kind <= maxT) { ++mErrDist; break; }
-->pragmas
      if (mDummyTokenPtr != t)
      {
         mDummyTokenPtr->kind = t->kind;
         mDummyTokenPtr->pos = t->pos;
         mDummyTokenPtr->col = t->col;
         mDummyTokenPtr->line = t->line;
         mDummyTokenPtr->next = nullptr;
         coco_string_delete(mDummyTokenPtr->val);
         mDummyTokenPtr->val = coco_string_create(t->val);
         t = mDummyTokenPtr;
      }
      la = t;
   }
   if (t->kind == _EOF)
   {
      EOF_Token();
   }
}

void Parser::Expect(int n)
{
   if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow)
{
   if (la->kind == n) Get();
   else
   {
      SynErr(n);
      while (!StartOf(follow)) Get();
   }
}

bool Parser::WeakSeparator(int n, int syFol, int repFol)
{
   if (la->kind == n) {Get(); return true;}
   else if (StartOf(repFol)) {return false;}
   else
   {
      SynErr(n);
      while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
         Get();
      }
      return StartOf(syFol);
   }
}

-->productions

// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Init>
   struct ExistsIfInitIsDefinedMarker{};

   struct InitIsMissingType
   {
      char dummy1;
   };

   struct InitExistsType
   {
      char dummy1; char dummy2;
   };

   // exists always
   template<typename U>
   static InitIsMissingType is_here(...);

   // exist only if ExistsIfInitIsDefinedMarker is defined
   template<typename U>
   static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

   enum { InitExists = (sizeof(is_here<T>(nullptr)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Destroy>
   struct ExistsIfDestroyIsDefinedMarker{};

   struct DestroyIsMissingType
   {
      char dummy1;
   };

   struct DestroyExistsType
   {
      char dummy1; char dummy2;
   };

   // exists always
   template<typename U>
   static DestroyIsMissingType is_here(...);

   // exist only if ExistsIfDestroyIsDefinedMarker is defined
   template<typename U>
   static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

   enum { DestroyExists = (sizeof(is_here<T>(nullptr)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller
{
   static void CallInit(T *t)
   {
      // nothing to do
   }
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true>
{
   static void CallInit(T *t)
   {
      t->Init();
   }
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller
{
   static void CallDestroy(T *t)
   {
      // nothing to do
   }
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true>
{
   static void CallDestroy(T *t)
   {
      t->Destroy();
   }
};

void Parser::InitParse()
{
   t = nullptr;
   la = mDummyTokenPtr = new Token();
   la->val = coco_string_create("Dummy Token");
   Get();
}
void Parser::Parse()
{
   InitParse();
-->parseRoot
}

Parser::Parser(Scanner* aScannerPtr)
{
-->constants
   ParserInitCaller<Parser>::CallInit(this);
   this->mScannerPtr = aScannerPtr;
   mErrorsPtr = new Errors();
}

bool Parser::StartOf(int s)
{
   const bool T = true;
   const bool x = false;

-->initialization

   return set[s][la->kind];
}

Parser::~Parser()
{
   ParserDestroyCaller<Parser>::CallDestroy(this);
   delete mErrorsPtr;
   delete mDummyTokenPtr;
}

char* Errors::GetStaticError(int n)
{
   char* s = nullptr;
   switch (n)
   {
-->errors
      default:
      break;
   }
   return s;
}

void Errors::SynErr(Token* tok, int n)
{
   cocochar_t* s = GetStaticError(n);
   if (! s)
   {
      ut::log::error() << "SynErr: " << n;
   }
   else
   {
      auto out = ut::log::error() << s;
      out.AddNote() << "Line: " << tok->line;
      out.AddNote() << "Col: " << tok->col;
   }
   coco_string_delete(s);
   count++;
}

void Errors::Error(Token* tok, const cocochar_t* s)
{
   auto out = ut::log::error() << s;
   out.AddNote() << "Line: " << tok->line;
   out.AddNote() << "Col: " << tok->col;
   count++;
}

void Errors::Warning(Token* tok, const cocochar_t* s)
{
   auto out = ut::log::warning() << s;
   out.AddNote() << "Line: " << tok->line;
   out.AddNote() << "Col: " << tok->col;
}

void Errors::Warning(const cocochar_t *s)
{
   ut::log::warning() << s;
}

void Errors::Exception(const cocochar_t* s)
{
   ut::log::fatal() << s;
   exit(1);
}

-->namespace_close
