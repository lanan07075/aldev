// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************
// ****************************************************************************
// Updated by Infoscitex, a DCS Company.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See util_script/source/script_parser/AAA_README.TXT.

#include "UtScriptLanguageParser.hpp"

namespace UtScriptLanguage
{

void Parser::SynErr(int n)
{
   if (mErrDist >= mMinErrDist)
      mErrorsPtr->SynErr(la, n);
   if (mErrDist == 0)
      Get();
   mErrDist = 0;
}

void Parser::SemErr(const cocochar_t* msg)
{
   if (mErrDist >= mMinErrDist)
      mErrorsPtr->Error(t, msg);
   mErrDist = 0;
}

void Parser::Get()
{
   for (;;)
   {
      t  = la;
      la = mScannerPtr->Scan();
      if (la->kind <= maxT)
      {
         ++mErrDist;
         break;
      }

      if (mDummyTokenPtr != t)
      {
         mDummyTokenPtr->kind = t->kind;
         mDummyTokenPtr->pos  = t->pos;
         mDummyTokenPtr->col  = t->col;
         mDummyTokenPtr->line = t->line;
         mDummyTokenPtr->next = nullptr;
         coco_string_delete(mDummyTokenPtr->val);
         mDummyTokenPtr->val = coco_string_create(t->val);
         t                   = mDummyTokenPtr;
      }
      la = t;
   }
   if (t->kind == _EOF)
   {
      EOF_Token();
   }
}

void Parser::Expect(int n)
{
   if (la->kind == n)
      Get();
   else
   {
      SynErr(n);
   }
}

void Parser::ExpectWeak(int n, int follow)
{
   if (la->kind == n)
      Get();
   else
   {
      SynErr(n);
      while (!StartOf(follow))
         Get();
   }
}

bool Parser::WeakSeparator(int n, int syFol, int repFol)
{
   if (la->kind == n)
   {
      Get();
      return true;
   }
   else if (StartOf(repFol))
   {
      return false;
   }
   else
   {
      SynErr(n);
      while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0)))
      {
         Get();
      }
      return StartOf(syFol);
   }
}

void Parser::Script()
{
   while (StartOf(1))
   {
      func_def(*mRootCx);
   }
}

void Parser::func_def(Cx& c)
{
   Token* fnIdent = nullptr;
   Ty*    ty;
   Fn     f;
   UsVal  fnSym;
   type(c, ty);
   Expect(_ident);
   c.SetRType(f, ty);
   fnIdent = t;
   Cx fncx(c);
   fncx.SetBlockType(Cx::cSCRIPT_BLOCK);
   formal_param_list(fncx, f);
   fnSym = c.AddEntry(fnIdent, f, false, &fncx);
   fncx.FuncDefStart(fnSym);
   block_func(fncx);
   c.FuncComplete(fnSym, fncx);
}

void Parser::basic_type()
{
   if (la->kind == _string)
   {
      Get();
   }
   else if (la->kind == _int)
   {
      Get();
   }
   else if (la->kind == _double)
   {
      Get();
   }
   else if (la->kind == _char)
   {
      Get();
   }
   else if (la->kind == _bool)
   {
      Get();
   }
   else
      SynErr(59);
}

void Parser::type(Cx& c, Ty*& ty)
{
   ty = nullptr;
   if (StartOf(2))
   {
      basic_type();
      ty = c.Type(t);
   }
   else if (la->kind == _ident)
   {
      Get();
      ty = c.Type(t);
      if (la->kind == 48 /* "<" */)
      {
         Get();
         std::pair<Ty*, Ty*> argtypes;
         type(c, argtypes.first);
         if (la->kind == _comma)
         {
            Get();
            type(c, argtypes.second);
         }
         Expect(49 /* ">" */);
         ty = c.qType(ty, argtypes);
      }
   }
   else
      SynErr(60);
}

void Parser::identifier(Cx& c, Val& v)
{
   Expect(_ident);
   v = c.Identifier(t);
}

void Parser::static_exp(Cx& c, Val& v)
{
   switch (la->kind)
   {
   case _null:
   case _null2:
   {
      if (la->kind == _null)
      {
         Get();
      }
      else
      {
         Get();
      }
      v = c.NullLiteral(t);
      break;
   }
   case _true:
   {
      Get();
      v = c.BoolLiteral(t);
      break;
   }
   case _false:
   {
      Get();
      v = c.BoolLiteral(t);
      break;
   }
   case _string_literal:
   {
      Get();
      v = c.StringLiteral(t);
      break;
   }
   case _char_literal:
   {
      Get();
      v = c.StringLiteral(t);
      break;
   }
   case _real_number:
   {
      Get();
      v = c.DoubleLiteral(t);
      break;
   }
   case _number:
   {
      Get();
      v = c.IntLiteral(t);
      break;
   }
   default:
      SynErr(61);
      break;
   }
}

void Parser::arg_list(Cx& c, ValList& args)
{
   Val arg;
   if (StartOf(3))
   {
      exp(c, arg);
      args.push_back(arg);
      while (la->kind == _comma)
      {
         Get();
         exp(c, arg);
         args.push_back(arg);
      }
   }
}

void Parser::exp(Cx& c, Val& v)
{
   exp1(c, v);
}

void Parser::block(Cx& c)
{
   Cx subcx(c);
   Expect(50 /* "{" */);
   while (StartOf(4))
   {
      stat(subcx);
   }
   Expect(_rbrace);
}

void Parser::stat(Cx& c)
{
   Val v;
   int statNum = c.BeginStat();
   if (la->kind == _do)
   {
      do_stat(c);
   }
   else if (la->kind == _while)
   {
      while_stat(c);
   }
   else if (la->kind == _if)
   {
      Get();
      Expect(_lparen);
      bool_exp(c, v);
      Expect(_rparen);
      int trueEnd;
      trueEnd = c.IfCond(v);
      Cx c1(c);
      stat(c1);
      bool hasElse = false;
      c1.EndContext();
      if (la->kind == _else)
      {
         Get();
         hasElse     = true;
         int elseEnd = c.IfTrueEnd(trueEnd, true);
         Cx  c2(c);
         stat(c2);
         c.IfElseEnd(elseEnd);
      }
      if (!hasElse)
         c.IfTrueEnd(trueEnd, false);
   }
   else if (la->kind == _return)
   {
      Get();
      if (StartOf(3))
      {
         exp(c, v);
      }
      c.Return(v);
      while (!(la->kind == _EOF || la->kind == _semicolon))
      {
         SynErr(62);
         Get();
      }
      Expect(_semicolon);
   }
   else if (la->kind == _break)
   {
      Get();
      c.Break();
      Expect(_semicolon);
   }
   else if (la->kind == _continue)
   {
      Get();
      c.Continue();
      Expect(_semicolon);
   }
   else if (la->kind == _for)
   {
      Get();
      Expect(_lparen);
      Val forCond;
      Cx  forCx(c);
      if (StartOf(5))
      {
         if (IsVarDecl(forCx))
         {
            var_decl(forCx);
         }
         else
         {
            assign_expr(forCx, v);
         }
      }
      forCx.SetBlockType(Cx::cFOR_BLOCK);
      Expect(_semicolon);
      exp(forCx, forCond);
      forCx.ForCond(forCond);
      Expect(_semicolon);
      if (la->kind == _ident)
      {
         assign_expr(forCx, v);
      }
      Expect(_rparen);
      forCx.ForInc();
      stat(forCx);
      forCx.EndContext();
   }
   else if (la->kind == _foreach)
   {
      Get();
      Val var1, var2;
      Val cont;
      Cx  feCx(c);
      Expect(_lparen);
      var_decl_expr(feCx, var1);
      if (la->kind == 51 /* ":" */)
      {
         Get();
         var_decl_expr(feCx, var2);
      }
      Expect(_in);
      exp(feCx, cont);
      Expect(_rparen);
      feCx.ForEachBegin(var1, var2, cont);
      stat(feCx);
      feCx.EndContext();
   }
   else if (la->kind == 50 /* "{" */)
   {
      block(c);
   }
   else if (la->kind == _extern)
   {
      extern_stat(c);
   }
   else if (StartOf(6))
   {
      stat2(c);
   }
   else
      SynErr(63);
   c.EndStat(statNum);
}

void Parser::block_func(Cx& c)
{
   while (StartOf(4))
   {
      stat(c);
   }
   Expect(_EOF);
}

void Parser::extern_stat(Cx& c)
{
   Ty *   ty(nullptr), *arg(nullptr);
   Fn     f;
   Token *argName(nullptr), *id;
   Expect(_extern);
   type(c, ty);
   Expect(_ident);
   id = t;
   if (la->kind == _lparen)
   {
      Get();
      if (StartOf(1))
      {
         type(c, arg);
         if (la->kind == _ident)
         {
            Get();
            argName = t;
         }
         c.AddParam(f, arg, argName);
         argName = nullptr;
         while (la->kind == _comma)
         {
            Get();
            type(c, arg);
            if (la->kind == _ident)
            {
               Get();
               argName = t;
            }
            c.AddParam(f, arg, argName);
            argName = nullptr;
         }
      }
      Expect(_rparen);
      c.SetRType(f, ty);
      c.AddEntry(id, f, true);
      Expect(_semicolon);
   }
   else if (la->kind == _semicolon)
   {
      c.VarDecl(ty, id, Val::cEXTERN_VARIABLE);
      Get();
   }
   else
      SynErr(64);
}

void Parser::var_decl_expr(Cx& c, Val& v)
{
   Ty* ty(nullptr);
   type(c, ty);
   Expect(_ident);
   v = c.VarDecl(ty, t, 0);
}

void Parser::var_decl(Cx& c)
{
   Ty* ty(nullptr);
   Val v;
   Val rhs;
   int varflags = 0;
   if (la->kind == _global || la->kind == _static || la->kind == _extern)
   {
      if (la->kind == _static)
      {
         Get();
         varflags = Val::cSTATIC_VARIABLE;
      }
      else if (la->kind == _extern)
      {
         Get();
         varflags |= Val::cEXTERN_VARIABLE;
      }
      else
      {
         Get();
         varflags |= Val::cGLOBAL_VARIABLE;
      }
   }
   type(c, ty);
   Expect(_ident);
   v               = c.VarDecl(ty, t, varflags);
   bool hasInitial = false;
   if (la->kind == _assign)
   {
      Get();
      c.VarDeclPreAssign(v);
      hasInitial = true;
      exp(c, rhs);
      v = c.Op(v, rhs, Cx::cASSIGN_INITIAL);
   }
   if (!hasInitial)
      c.VarDeclInit(v);
   while (la->kind == _comma)
   {
      Get();
      Expect(_ident);
      v          = c.VarDecl(ty, t, varflags);
      hasInitial = false;
      if (la->kind == _assign)
      {
         Get();
         c.VarDeclPreAssign(v);
         hasInitial = true;
         exp(c, rhs);
         v = c.Op(v, rhs, Cx::cASSIGN_INITIAL);
      }
      if (!hasInitial)
         c.VarDeclInit(v);
   }
}

void Parser::do_stat(Cx& c)
{
   Cx doCx(c);
   doCx.SetBlockType(Cx::cDO_BLOCK);
   Expect(_do);
   Val v;
   stat(doCx);
   doCx.DoWhileStart();
   Expect(_while);
   Expect(_lparen);
   bool_exp(doCx, v);
   Expect(_rparen);
   doCx.DoCond(v);
   Expect(_semicolon);
}

void Parser::bool_exp(Cx& c, Val& v)
{
   exp(c, v);
}

void Parser::while_stat(Cx& c)
{
   Val v;
   Cx  whileCx(c);
   whileCx.SetBlockType(Cx::cWHILE_BLOCK);
   Expect(_while);
   Expect(_lparen);
   bool_exp(whileCx, v);
   Expect(_rparen);
   whileCx.WhileCond(v);
   stat(whileCx);
   whileCx.EndContext();
}

void Parser::assign_expr(Cx& c, Val& v)
{
   Val rhs;
   int op;
   identifier(c, v);
   AssignOp(op);
   exp(c, rhs);
   c.Op(v, rhs, op);
}

void Parser::stat2(Cx& c)
{
   Val v;
   if (IsVarDecl(c))
   {
      var_decl(c);
      Expect(_semicolon);
   }
   else if (IsAssignment())
   {
      assign_expr(c, v);
      while (!(la->kind == _EOF || la->kind == _semicolon))
      {
         SynErr(65);
         Get();
      }
      Expect(_semicolon);
   }
   else if (StartOf(3))
   {
      exp(c, v);
      while (!(la->kind == _EOF || la->kind == _semicolon))
      {
         SynErr(66);
         Get();
      }
      Expect(_semicolon);
   }
   else
      SynErr(67);
}

void Parser::initializer_list(Cx& c, Val& v)
{
   bool hasKey = false;
   Val  u, w;
   Expect(50 /* "{" */);
   v = c.NewInitializerList();
   if (StartOf(3))
   {
      exp(c, u);
      if (la->kind == 51 /* ":" */)
      {
         Get();
         exp(c, w);
         hasKey = true;
      }
      c.AddToInitializerList(v, u, hasKey ? &w : nullptr);
      hasKey = false;
      while (IsInitializerEntry())
      {
         Expect(_comma);
         exp(c, u);
         if (la->kind == 51 /* ":" */)
         {
            Get();
            exp(c, w);
            hasKey = true;
         }
         c.AddToInitializerList(v, u, hasKey ? &w : nullptr);
         hasKey = false;
      }
   }
   if (la->kind == _comma)
   {
      Get();
   }
   Expect(_rbrace);
}

void Parser::AssignOp(int& op)
{
   if (la->kind == _assign)
   {
      Get();
      op = Cx::cASSIGN;
   }
   else if (la->kind == _plus_assign)
   {
      Get();
      op = Cx::cASSIGN_PLUS;
   }
   else if (la->kind == _minus_assign)
   {
      Get();
      op = Cx::cASSIGN_MINUS;
   }
   else if (la->kind == _times_assign)
   {
      Get();
      op = Cx::cASSIGN_TIMES;
   }
   else if (la->kind == _div_assign)
   {
      Get();
      op = Cx::cASSIGN_DIV;
   }
   else
      SynErr(68);
}

void Parser::exp1(Cx& c, Val& v)
{
   exp2(c, v);
   while (la->kind == _or)
   {
      Get();
      UsVal result;
      int   jumpOffset = c.OrCheck(v, result);
      Val   rhs;
      exp2(c, rhs);
      v = c.OrComplete(result, rhs, jumpOffset);
   }
}

void Parser::exp2(Cx& c, Val& v)
{
   exp3(c, v);
   while (la->kind == _and)
   {
      Get();
      UsVal result;
      int   jumpOffset = c.AndCheck(v, result);
      Val   rhs;
      exp3(c, rhs);
      v = c.AndComplete(result, rhs, jumpOffset);
   }
}

void Parser::exp3(Cx& c, Val& v)
{
   exp_eq(c, v);
   while (la->kind == 52 /* "^" */)
   {
      Get();
      exp_eq(c, v);
   }
}

void Parser::exp_eq(Cx& c, Val& v)
{
   int op;
   exp_test(c, v);
   while (la->kind == _eq || la->kind == _ne)
   {
      EqOp(op);
      Val rhs;
      exp_test(c, rhs);
      v = c.Op(v, rhs, op);
   }
}

void Parser::EqOp(int& op)
{
   if (la->kind == _eq)
   {
      Get();
      op = Cx::cEQ;
   }
   else if (la->kind == _ne)
   {
      Get();
      op = Cx::cNE;
   }
   else
      SynErr(69);
}

void Parser::exp_test(Cx& c, Val& v)
{
   int op;
   exp_add(c, v);
   while (StartOf(7))
   {
      TestOp(op);
      Val rhs;
      exp_add(c, rhs);
      v = c.Op(v, rhs, op);
   }
}

void Parser::TestOp(int& op)
{
   if (la->kind == 48 /* "<" */)
   {
      Get();
      op = Cx::cLT;
   }
   else if (la->kind == 49 /* ">" */)
   {
      Get();
      op = Cx::cGT;
   }
   else if (la->kind == _le)
   {
      Get();
      op = Cx::cLE;
   }
   else if (la->kind == _ge)
   {
      Get();
      op = Cx::cGE;
   }
   else
      SynErr(70);
}

void Parser::exp_add(Cx& c, Val& v)
{
   int op(0);
   exp_mult(c, v);
   while (la->kind == _plus || la->kind == _minus)
   {
      AddOp(op);
      Val rhs;
      exp_mult(c, rhs);
      v = c.Op(v, rhs, op);
   }
}

void Parser::AddOp(int& op)
{
   if (la->kind == _plus)
   {
      Get();
      op = Cx::cADD;
   }
   else if (la->kind == _minus)
   {
      Get();
      op = Cx::cSUBTRACT;
   }
   else
      SynErr(71);
}

void Parser::exp_mult(Cx& c, Val& v)
{
   int op;
   exp5(c, v);
   while (la->kind == 53 /* "*" */ || la->kind == 54 /* "/" */)
   {
      MulOp(op);
      Val rhs;
      exp5(c, rhs);
      v = c.Op(v, rhs, op);
   }
}

void Parser::MulOp(int& op)
{
   if (la->kind == 53 /* "*" */)
   {
      Get();
      op = Cx::cMULTIPLY;
   }
   else if (la->kind == 54 /* "/" */)
   {
      Get();
      op = Cx::cDIVIDE;
   }
   else
      SynErr(72);
}

void Parser::exp5(Cx& c, Val& v)
{
   Ty* ty = nullptr;
   if (IsCast(c))
   {
      Expect(_lparen);
      type(c, ty);
      Expect(_rparen);
      exp5(c, v);
      v = c.Cast(v, ty);
   }
   else if (la->kind == 55 /* "!" */)
   {
      Get();
      exp5(c, v);
      v = c.Op(v, Cx::cNOT);
   }
   else if (StartOf(8))
   {
      exp6(c, v);
   }
   else
      SynErr(73);
}

void Parser::exp6(Cx& c, Val& v)
{
   int unaryOp = -1;
   if (la->kind == _plus || la->kind == _minus)
   {
      if (la->kind == _plus)
      {
         Get();
         unaryOp = Cx::cUNARY_PLUS;
      }
      else
      {
         Get();
         unaryOp = Cx::cUNARY_MINUS;
      }
   }
   exp7(c, v);
   if (unaryOp >= 0)
      v = c.Op(v, unaryOp);
}

void Parser::exp7(Cx& c, Val& v)
{
   atom(c, v);
   while (la->kind == _dot || la->kind == _r_arrow || la->kind == 56 /* "[" */)
   {
      trailer(c, v);
   }
}

void Parser::atom(Cx& c, Val& v)
{
   Ty* ty(nullptr);
   if (la->kind == _lparen)
   {
      Get();
      exp1(c, v);
      Expect(_rparen);
   }
   else if (StartOf(9))
   {
      static_exp(c, v);
   }
   else if (IsType(c))
   {
      type(c, ty);
      if (la->kind == _dot)
      {
         Get();
         Expect(_ident);
         v = c.GetAttribute(ty, t);
         Expect(_lparen);
         ValList args;
         arg_list(c, args);
         Expect(_rparen);
         v = c.Call(v, args);
      }
      else if (la->kind == _lparen)
      {
         Get();
         ValList args;
         arg_list(c, args);
         Expect(_rparen);
         v = c.Ctor(ty, args);
      }
      else
         SynErr(74);
   }
   else if (IsScript(c))
   {
      identifier(c, v);
      Expect(_lparen);
      ValList args;
      arg_list(c, args);
      Expect(_rparen);
      v = c.Call(v, args);
   }
   else if (la->kind == _ident)
   {
      identifier(c, v);
   }
   else if (la->kind == 50 /* "{" */)
   {
      initializer_list(c, v);
   }
   else
      SynErr(75);
}

void Parser::trailer(Cx& c, Val& v)
{
   Val idx;
   if (la->kind == 56 /* "[" */)
   {
      Get();
      exp1(c, idx);
      Expect(57 /* "]" */);
      Val rhs;
      if (la->kind == _assign)
      {
         Get();
         exp(c, rhs);
      }
      v = c.Op(v, idx, rhs, Cx::cINDEX);
   }
   else if (la->kind == _dot)
   {
      Get();
      Expect(_ident);
      const char* ident = t->val;
      if (la->kind == _lparen)
      {
         Get();
         v = c.GetClassMethod(v, ident);
         ValList args;
         arg_list(c, args);
         Expect(_rparen);
         v = c.Call(v, args);
      }
      else if (StartOf(10))
      {
         v = c.GetClassVariable(v, ident);
         if (StartOf(11))
         {
            Val rhs;
            int op;
            AssignOp(op);
            exp(c, rhs);
            c.Op(v, rhs, op);
         }
      }
      else
         SynErr(76);
   }
   else if (la->kind == _r_arrow)
   {
      Get();
      Expect(_ident);
      v = c.GetDynAttribute(v, t);
      if (la->kind == _lparen)
      {
         Get();
         ValList args;
         arg_list(c, args);
         Expect(_rparen);
         v = c.Call(v, args);
      }
      else if (StartOf(10))
      {
         if (StartOf(11))
         {
            Val rhs;
            int op;
            AssignOp(op);
            exp(c, rhs);
            c.Op(v, rhs, op);
         }
      }
      else
         SynErr(77);
   }
   else
      SynErr(78);
}

void Parser::formal_param_list(Cx& c, Fn& f)
{
   Ty* ty = nullptr;
   Expect(_lparen);
   if (StartOf(1))
   {
      type(c, ty);
      Expect(_ident);
      c.AddParam(f, ty, t, 1);
      while (la->kind == _comma)
      {
         Get();
         type(c, ty);
         Expect(_ident);
         c.AddParam(f, ty, t, 1);
      }
   }
   Expect(_rparen);
}


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Init>
   struct ExistsIfInitIsDefinedMarker
   {
   };

   struct InitIsMissingType
   {
      char dummy1;
   };

   struct InitExistsType
   {
      char dummy1;
      char dummy2;
   };

   // exists always
   template<typename U>
   static InitIsMissingType is_here(...);

   // exist only if ExistsIfInitIsDefinedMarker is defined
   template<typename U>
   static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

   enum
   {
      InitExists = (sizeof(is_here<T>(nullptr)) == sizeof(InitExistsType))
   };
};

template<typename T>
struct ParserDestroyExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Destroy>
   struct ExistsIfDestroyIsDefinedMarker
   {
   };

   struct DestroyIsMissingType
   {
      char dummy1;
   };

   struct DestroyExistsType
   {
      char dummy1;
      char dummy2;
   };

   // exists always
   template<typename U>
   static DestroyIsMissingType is_here(...);

   // exist only if ExistsIfDestroyIsDefinedMarker is defined
   template<typename U>
   static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

   enum
   {
      DestroyExists = (sizeof(is_here<T>(nullptr)) == sizeof(DestroyExistsType))
   };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller
{
   static void CallInit(T* t)
   {
      // nothing to do
   }
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true>
{
   static void CallInit(T* t) { t->Init(); }
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller
{
   static void CallDestroy(T* t)
   {
      // nothing to do
   }
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true>
{
   static void CallDestroy(T* t) { t->Destroy(); }
};

void Parser::InitParse()
{
   t  = nullptr;
   la = mDummyTokenPtr = new Token();
   la->val             = coco_string_create("Dummy Token");
   Get();
}
void Parser::Parse()
{
   InitParse();
   Script();
   Expect(0);
}

Parser::Parser(Scanner* aScannerPtr)
{
   maxT = 58;

   ParserInitCaller<Parser>::CallInit(this);
   this->mScannerPtr = aScannerPtr;
   mErrorsPtr        = new Errors();
}

bool Parser::StartOf(int s)
{
   const bool T = true;
   const bool x = false;

   static bool set[12][60] = {
      {T, x, x, x, x, x, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
      {x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, T, T, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
      {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, T, T, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
      {x, T, T, T, T, T, x, x, T, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, T, T, T, T, T, T, T, T, T, x, x, x, x, x, T, x, x, x, x, T, x, x, x, x},
      {x, T, T, T, T, T, x, x, T, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, T, T, T, T,
       x, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, x, x, x, x, T, x, x, x, x},
      {x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, T, T, T, T, T, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x},
      {x, T, T, T, T, T, x, x, T, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, x, x, x, x, T, x, x, x, x},
      {x, x, x, x, x, x, x, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x},
      {x, T, T, T, T, T, x, x, T, x, x, x, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, T, T, T, T, T, T, T, T, T, x, x, x, x, x, T, x, x, x, x, x, x, x, x, x},
      {x, x, T, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
       x, x, x, x, x, x, T, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
      {x, x, x, x, x, x, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, T, x, T, T, T, T, x, T, T, x, x},
      {x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x, x, x, x, T, T, T, T, x, x, x, x, x,
       x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x}};


   return set[s][la->kind];
}

Parser::~Parser()
{
   ParserDestroyCaller<Parser>::CallDestroy(this);
   delete mErrorsPtr;
   delete mDummyTokenPtr;
}

char* Errors::GetStaticError(int n)
{
   char* s = nullptr;
   switch (n)
   {
   case 0:
      s = coco_string_create("EOF expected");
      break;
   case 1:
      s = coco_string_create("identifier expected");
      break;
   case 2:
      s = coco_string_create("number expected");
      break;
   case 3:
      s = coco_string_create("real_number expected");
      break;
   case 4:
      s = coco_string_create("string_literal expected");
      break;
   case 5:
      s = coco_string_create("char_literal expected");
      break;
   case 6:
      s = coco_string_create("\".\" expected");
      break;
   case 7:
      s = coco_string_create("\";\" expected");
      break;
   case 8:
      s = coco_string_create("\"(\" expected");
      break;
   case 9:
      s = coco_string_create("\")\" expected");
      break;
   case 10:
      s = coco_string_create("\"=\" expected");
      break;
   case 11:
      s = coco_string_create("\"==\" expected");
      break;
   case 12:
      s = coco_string_create("\"!=\" expected");
      break;
   case 13:
      s = coco_string_create("\">=\" expected");
      break;
   case 14:
      s = coco_string_create("\"<=\" expected");
      break;
   case 15:
      s = coco_string_create("\"+\" expected");
      break;
   case 16:
      s = coco_string_create("\"-\" expected");
      break;
   case 17:
      s = coco_string_create("\"&&\" expected");
      break;
   case 18:
      s = coco_string_create("\"||\" expected");
      break;
   case 19:
      s = coco_string_create("\"}\" expected");
      break;
   case 20:
      s = coco_string_create("\",\" expected");
      break;
   case 21:
      s = coco_string_create("\"+=\" expected");
      break;
   case 22:
      s = coco_string_create("\"-=\" expected");
      break;
   case 23:
      s = coco_string_create("\"*=\" expected");
      break;
   case 24:
      s = coco_string_create("\"/=\" expected");
      break;
   case 25:
      s = coco_string_create("\"->\" expected");
      break;
   case 26:
      s = coco_string_create("do expected");
      break;
   case 27:
      s = coco_string_create("if expected");
      break;
   case 28:
      s = coco_string_create("for expected");
      break;
   case 29:
      s = coco_string_create("foreach expected");
      break;
   case 30:
      s = coco_string_create("in expected");
      break;
   case 31:
      s = coco_string_create("else expected");
      break;
   case 32:
      s = coco_string_create("while expected");
      break;
   case 33:
      s = coco_string_create("break expected");
      break;
   case 34:
      s = coco_string_create("continue expected");
      break;
   case 35:
      s = coco_string_create("return expected");
      break;
   case 36:
      s = coco_string_create("null expected");
      break;
   case 37:
      s = coco_string_create("null2 expected");
      break;
   case 38:
      s = coco_string_create("true expected");
      break;
   case 39:
      s = coco_string_create("false expected");
      break;
   case 40:
      s = coco_string_create("string expected");
      break;
   case 41:
      s = coco_string_create("int expected");
      break;
   case 42:
      s = coco_string_create("double expected");
      break;
   case 43:
      s = coco_string_create("char expected");
      break;
   case 44:
      s = coco_string_create("bool expected");
      break;
   case 45:
      s = coco_string_create("global expected");
      break;
   case 46:
      s = coco_string_create("static expected");
      break;
   case 47:
      s = coco_string_create("extern expected");
      break;
   case 48:
      s = coco_string_create("\"<\" expected");
      break;
   case 49:
      s = coco_string_create("\">\" expected");
      break;
   case 50:
      s = coco_string_create("\"{\" expected");
      break;
   case 51:
      s = coco_string_create("\":\" expected");
      break;
   case 52:
      s = coco_string_create("\"^\" expected");
      break;
   case 53:
      s = coco_string_create("\"*\" expected");
      break;
   case 54:
      s = coco_string_create("\"/\" expected");
      break;
   case 55:
      s = coco_string_create("\"!\" expected");
      break;
   case 56:
      s = coco_string_create("\"[\" expected");
      break;
   case 57:
      s = coco_string_create("\"]\" expected");
      break;
   case 58:
      s = coco_string_create("??? expected");
      break;
   case 59:
      s = coco_string_create("invalid basic_type");
      break;
   case 60:
      s = coco_string_create("invalid type");
      break;
   case 61:
      s = coco_string_create("syntax error");
      break;
   case 62:
      s = coco_string_create("unexpected symbol");
      break;
   case 63:
      s = coco_string_create("invalid statement");
      break;
   case 64:
      s = coco_string_create("syntax error");
      break;
   case 65:
      s = coco_string_create("unexpected symbol");
      break;
   case 66:
      s = coco_string_create("unexpected symbol");
      break;
   case 67:
      s = coco_string_create("invalid statement");
      break;
   case 68:
      s = coco_string_create("invalid AssignOp");
      break;
   case 69:
      s = coco_string_create("invalid EqOp");
      break;
   case 70:
      s = coco_string_create("invalid TestOp");
      break;
   case 71:
      s = coco_string_create("invalid AddOp");
      break;
   case 72:
      s = coco_string_create("invalid MulOp");
      break;
   case 73:
      s = coco_string_create("invalid expression");
      break;
   case 74:
      s = coco_string_create("invalid value");
      break;
   case 75:
      s = coco_string_create("invalid value");
      break;
   case 76:
      s = coco_string_create("syntax error in trailing expression");
      break;
   case 77:
      s = coco_string_create("syntax error in trailing expression");
      break;
   case 78:
      s = coco_string_create("syntax error in trailing expression");
      break;

   default:
      break;
   }
   return s;
}

void Errors::SynErr(Token* tok, int n)
{
   cocochar_t* s = GetStaticError(n);
   if (!s)
   {
      ut::log::error() << "SynErr: " << n;
   }
   else
   {
      auto out = ut::log::error() << s;
      out.AddNote() << "Line: " << tok->line;
      out.AddNote() << "Col: " << tok->col;
   }
   coco_string_delete(s);
   count++;
}

void Errors::Error(Token* tok, const cocochar_t* s)
{
   auto out = ut::log::error() << s;
   out.AddNote() << "Line: " << tok->line;
   out.AddNote() << "Col: " << tok->col;
   count++;
}

void Errors::Warning(Token* tok, const cocochar_t* s)
{
   auto out = ut::log::warning() << s;
   out.AddNote() << "Line: " << tok->line;
   out.AddNote() << "Col: " << tok->col;
}

void Errors::Warning(const cocochar_t* s)
{
   ut::log::warning() << s;
}

void Errors::Exception(const cocochar_t* s)
{
   ut::log::fatal() << s;
   exit(1);
}

} // namespace UtScriptLanguage
